{"meta":{"title":"秋名山车神的博客","subtitle":"车神维基","description":"我本微末凡尘，却也心向天空。","author":"车神","url":"http://www.cheshen.wiki"},"pages":[{"title":"","date":"2017-03-29T12:04:00.375Z","updated":"2017-03-29T12:04:00.375Z","comments":true,"path":"404.html","permalink":"http://www.cheshen.wiki/404.html","excerpt":"","text":""},{"title":"关于我","date":"2016-10-21T16:02:07.000Z","updated":"2016-10-25T15:06:05.802Z","comments":true,"path":"about/index.html","permalink":"http://www.cheshen.wiki/about/index.html","excerpt":"","text":"联系方式Email: meteorshield@gmail.comQQ: 790625271 基本信息男/90后/天蝎座所在城市：广东深圳学历：专科未毕业(中途离开学校)工作年限：三年 个人简介曾担任Java全栈工程师，参加过大型项目开发。精通Spring，Hibernate等框架，开发过简易版Spring框架。熟悉MySQL性能优化。目前Python作为首选语言，在Github贡献过requests，pymysql等主流Python库。对Python图像识别，数据采集，网站建设，自动化测试等方面有比较深的了解。在慕课网担任讲师。喜欢有挑战，创新，妹子多的团队。 技能清单掌握语言：Python/Java/HTML/JavaScript前端框架：Zepto/Bootstrap/AngularJS/JQuery数据库相关：MySQL/Oracle/SQLite其他技能：微信公众号开发"},{"title":"日程","date":"2016-10-21T16:05:09.000Z","updated":"2016-10-21T16:09:53.695Z","comments":true,"path":"schedule/index.html","permalink":"http://www.cheshen.wiki/schedule/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-10-21T16:02:33.000Z","updated":"2016-10-21T16:02:34.919Z","comments":true,"path":"tags/index.html","permalink":"http://www.cheshen.wiki/tags/index.html","excerpt":"","text":""},{"title":"小程序","date":"2016-10-26T14:41:42.557Z","updated":"2016-10-26T14:41:42.557Z","comments":true,"path":"small/index.html","permalink":"http://www.cheshen.wiki/small/index.html","excerpt":"","text":"注意事项：本页面所有小程序，你可以用在任何途径，如果可能的话，可以加上本站的链接或扫码捐献~ 绚丽的时钟阿尔法狗下五子棋"},{"title":"分类","date":"2016-10-21T16:00:33.000Z","updated":"2016-10-21T16:00:36.074Z","comments":true,"path":"categories/index.html","permalink":"http://www.cheshen.wiki/categories/index.html","excerpt":"","text":""},{"title":"","date":"2016-10-25T15:10:45.194Z","updated":"2016-04-01T15:34:01.426Z","comments":true,"path":"small/AlphaGo/index.css","permalink":"http://www.cheshen.wiki/small/AlphaGo/index.css","excerpt":"","text":".chess{ display: block; margin: 50px auto; box-shadow: -2px -2px 2px #EFEFEF, 5px 5px 5px #B9B9B9; }"},{"title":"","date":"2016-10-26T14:00:34.149Z","updated":"2016-10-26T14:00:34.149Z","comments":true,"path":"small/time/index.html","permalink":"http://www.cheshen.wiki/small/time/index.html","excerpt":"","text":"绚丽的时钟 当前浏览器不支持Canvas，请更换浏览器后再试"},{"title":"","date":"2016-10-25T15:10:45.198Z","updated":"2016-04-02T10:06:10.316Z","comments":true,"path":"small/AlphaGo/win.js","permalink":"http://www.cheshen.wiki/small/AlphaGo/win.js","excerpt":"","text":"//用来计算所有赢的情况的数据结构 myGain = [ [0,0,1,1,0], [0,1,1,0], [1,0,1,0] ]; comGain = [ [0,0,2,2,0], [0,2,2,0], [2,0,2,0] ];"},{"title":"","date":"2016-10-26T13:51:29.467Z","updated":"2016-10-26T13:51:29.467Z","comments":true,"path":"small/AlphaGo/index.html","permalink":"http://www.cheshen.wiki/small/AlphaGo/index.html","excerpt":"","text":"五子棋 您的浏览器不支持audio，请使用其他浏览器或极速模式。 您的浏览器不支持canvas，请使用其他浏览器或极速模式。"},{"title":"","date":"2016-10-26T12:48:11.694Z","updated":"2016-10-26T12:48:11.694Z","comments":true,"path":"small/AlphaGo/chess.js","permalink":"http://www.cheshen.wiki/small/AlphaGo/chess.js","excerpt":"","text":"/** * Created by Administrator on 2016/3/31. */ var chess; //canvas对象 var downChess; //audio对象 var CHESS_WIDTH; //棋盘的高度 var CHESS_HEIGTH; //棋盘的宽度 var over = false; //表示是否有人赢了 var chessPen; var LINE; //一共有棋盘有多少行多少列 var LINTTOPADDIN; //棋盘的线距离棋盘左右上下的距离 var LINE_SIZEPX; //棋盘每条线的间隔 var isBlack = true; //用来存储下一个棋子的颜色，true为黑棋，默认为黑棋先下 var chessMap = []; //存储棋盘的棋子，0代表当前位置没有棋子，1代表黑棋，2代表白棋 var wins = []; //赢法数组 [x][y][k] x y 代表棋盘上的一个点 k代表第几种赢法 var myWin = []; //我方的赢法统计数组 var comWin = []; //计算机方的赢法统计数组 var count = 0; //代表有多少种赢法 /** wins start **/ //初始化数组 for (var x = 0; x < 15; x++) { wins[x] = []; for (var y = 0; y < 15; y++) { wins[x][y] = []; } } //横排的赢法 for (var x = 0; x < 15; x++) { for (var y = 0; y < 11; y++) { for (var k = 0; k < 5; k++) { wins[x][y + k][count] = true; } count++; } } //竖排的赢法 for (var x = 0; x < 15; x++) { for (var y = 0; y < 11; y++) { for (var k = 0; k < 5; k++) { wins[y + k][x][count] = true; } count++; } } //正斜线的赢法 for (var x = 0; x < 11; x++) { for (var y = 0; y < 11; y++) { for (var k = 0; k < 5; k++) { wins[x + k][y + k][count] = true; } count++; } } //反斜线的赢法 for (var x = 0; x < 11; x++) { for (var y = 14; y > 3; y--) { for (var k = 0; k < 5; k++) { wins[x + k][y - k][count] = true; } count++; } } /** wins end **/ /** 赢法统计数组初始化开始 **/ for (var i = 0; i < count; i++) { myWin[i] = 0; comWin[i] = 0; } /** 赢法统计数组初始化结束 **/ console.log(\"五子棋一共有 \" + count + \"种赢法\"); //打印日志 window.onload = function() { infoStart(); } var infoStart = function() { chess = document.getElementById(\"chess\"); downChess = document.getElementById(\"downChess\"); chessPen = chess.getContext(\"2d\"); chessPen.strokeStyle = \"#B9B9B9\"; CHESS_WIDTH = chess.width; //棋盘的高度 CHESS_HEIGTH = chess.height; //棋盘的宽度 LINE = 15; //一共有棋盘有多少行多少列 LINTTOPADDIN = 15; //棋盘的线距离棋盘左右上下的距离 LINE_SIZEPX = 30; //棋盘每条线的间隔 drawCheckerBoard(); //初始化棋盘 reloadBoard(); //初始化棋子 //棋盘单击事件 chess.onclick = function(e) { //如果已经有人获胜，就不处理 if (over) { return; } //只有黑棋才能手动下棋 if (!isBlack) { return; } var x = Math.floor(e.offsetX / LINE_SIZEPX); var y = Math.floor(e.offsetY / LINE_SIZEPX); if (chessMap[x][y] == 0) { drawOneChess(x, y, isBlack); chessMap[x][y] = 1; //黑棋 } else { return; } //遍历所有的赢法 for (var k = 0; k < count; k++) { //如果为true说明我们在K种赢法上面胜算大了一步 if (wins[x][y][k]) { myWin[k]++; //我方胜算统计增加 comWin[k] = 6; //计算机在这种赢法就不可能赢，设置一个异常的值6 //说明黑棋已经赢了 if (myWin[k] == \"5\") { window.alert(\"恭喜你获胜！\"); over = true; } } } //如果还没有结束，我们让计算机下棋 if (!over) { isBlack = !isBlack; //下一个棋 computerAI(); } }; } //初始化棋子 var reloadBoard = function() { for (var i = 0; i < LINE; i++) { chessMap[i] = []; for (var j = 0; j < LINE; j++) { chessMap[i][j] = 0; } } } //计算机AI下棋 var computerAI = function() { var myScore = []; //用户棋盘上点的得分 var comScore = []; //电脑棋盘上点的得分 var max = 0; //保存最高的分数 var maxX = 0, maxY = 0; //最高分的点的坐标 var myK = 0; //用户下了某一个点之后，将会产生多少个符合赢得条件 var comK = 0; //计算机下了某一个点之后，将会产生多少个符合赢得条件 var ruleCount = 0; for (var x = 0; x < 15; x++) { myScore[x] = []; comScore[x] = []; for (var y = 0; y < 15; y++) { myScore[x][y] = 0; comScore[x][y] = 0; } } for (var x = 0; x < 15; x++) { for (var y = 0; y < 15; y++) { //如果棋盘上这个点没有子 if (chessMap[x][y] == 0) { //检查是否有符合规则的棋子 if (upAspect(x, y, 0, -1, 1)) { ruleCount++; } if (downAspect(x, y, 0, -1, 1)) { ruleCount++; } if (leftAspect(x, y, 0, -1, 1)) { ruleCount++; } if (rightAspect(x, y, 0, -1, 1)) { ruleCount++; } if (upLeftAspect(x, y, 0, -1, 1)) { ruleCount++; } if (rightDownAspect(x, y, 0, -1, 1)) { ruleCount++; } if (rightUpAspect(x, y, 0, -1, 1)) { ruleCount++; } if (leftDownAspect(x, y, 0, -1, 1)) { ruleCount++; } //规则至少要有两个成立才可以 if (ruleCount >= 2) { myScore[x][y] += 4000; ruleCount = 0; } else { ruleCount = 0; } //电脑落子 //检查是否有符合规则的棋子 if (upAspect(x, y, 0, -1, 2)) { ruleCount++; } if (downAspect(x, y, 0, -1, 2)) { ruleCount++; } if (leftAspect(x, y, 0, -1, 2)) { ruleCount++; } if (rightAspect(x, y, 0, -1, 2)) { ruleCount++; } if (upLeftAspect(x, y, 0, -1, 2)) { ruleCount++; } if (rightDownAspect(x, y, 0, -1, 2)) { ruleCount++; } if (rightUpAspect(x, y, 0, -1, 2)) { ruleCount++; } if (leftDownAspect(x, y, 0, -1, 2)) { ruleCount++; } //规则至少要有两个成立才可以 if (ruleCount >= 2) { comScore[x][y] += 8000; ruleCount = 0; } else { ruleCount = 0; } for (var k = 0; k < count; k++) { if (wins[x][y][k]) { //判断黑棋的子，然后判断如何拦截 if (myWin[k] == 1) { myScore[x][y] += 200; } else if (myWin[k] == 2) { myScore[x][y] += 400; } else if (myWin[k] == 3) { myScore[x][y] += 2000; } else if (myWin[k] == 4) { myScore[x][y] += 10000; } //判断计算机棋盘子每一步的分数 if (comWin[k] == 1) { comScore[x][y] += 220; } else if (comWin[k] == 2) { comScore[x][y] += 420 } else if (comWin[k] == 3) { comScore[x][y] += 2100 } else if (comWin[k] == 4) { comScore[x][y] += 20000 } } } //判断拦截用户位置的分数最高 if (myScore[x][y] > max) { max = myScore[x][y]; maxX = x; maxY = y; } else if (myScore[x][y] == max) { if (comScore[x][y] > comScore[maxX][maxY]) { maxX = x; maxY = y; } } //判断自己下哪里分数最高 if (comScore[x][y] > max) { max = comScore[x][y]; maxX = x; maxY = y; } else if (comScore[x][y] == max) { if (myScore[x][y] > myScore[maxX][maxY]) { maxX = x; maxY = y; } } } } } //计算机落子 drawOneChess(maxX, maxY, false); //把棋盘上的一个点设置为计算机落了子 chessMap[maxX][maxY] = 2; //遍历所有的赢法 for (var k = 0; k < count; k++) { //如果为true说明我们在K种赢法上面胜算大了一步 if (wins[maxX][maxY][k]) { comWin[k]++; //我方胜算统计增加 myWin[k] = 6; //计算机在这种赢法就不可能赢，设置一个异常的值6 //说明黑棋已经赢了 if (comWin[k] == \"5\") { window.alert(\"很遗憾，你输了！\"); over = true; } } } //如果还没有结束，我们让计算机下棋 if (!over) { isBlack = !isBlack; //下一个棋 } } /** 检测棋盘上一个点的上方有多少个黑子 x = 棋子的纵坐标 0 - 14 y = 棋子的横坐标 0 - 14 isNull = 0 为没有棋子 isNull = 1 为有黑棋 isNull = 2 为有白棋 isNull 初始化为 -1 代表到达边界 chessType = 1 代表黑棋 chessType = 2 代表白棋 **/ var upAspect = function(x, y, flag, isNull, chessType) { var thisX = x; var thisY = y; //黑棋用户 if (chessType == 1) { for (var i = 0; i < myGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < myGain[i].length; j++) { if (y == -1) { return false; } if (chessMap[x][y] == myGain[i][j]) { winCount++; y--; } } if (winCount == myGain[i].length) { return true; } } return false; } else { for (var i = 0; i < comGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < comGain[i].length; j++) { if (y == -1) { return false; } if (chessMap[x][y] == comGain[i][j]) { winCount++; y--; } } if (winCount == comGain[i].length) { return true; } } return false; } } //检测棋盘上一个点的下方有多少个黑子 var downAspect = function(x, y, flag, isNull, chessType) { var thisX = x; var thisY = y; //黑棋用户 if (chessType == 1) { for (var i = 0; i < myGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < myGain[i].length; j++) { if (y == 15) { return false; } if (chessMap[x][y] == myGain[i][j]) { winCount++; y++; } } if (winCount == myGain[i].length) { return true; } } return false; } else { for (var i = 0; i < comGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < comGain[i].length; j++) { if (y == 15) { return false; } if (chessMap[x][y] == comGain[i][j]) { winCount++; y++; } } if (winCount == comGain[i].length) { return true; } } return false; } } //检测棋盘上一个点的左方有多少个黑子 //y轴不变，x-- var leftAspect = function(x, y, flag, isNull, chessType) { var thisX = x; var thisY = y; //黑棋用户 if (chessType == 1) { for (var i = 0; i < myGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < myGain[i].length; j++) { if (x == -1) { //x的本身就在左方的边界，左方不存在任何东西，直接返回 return false; } if (chessMap[x][y] == myGain[i][j]) { winCount++; x--; } } if (winCount == myGain[i].length) { return true; } } return false; } else { for (var i = 0; i < comGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < comGain[i].length; j++) { if (x == -1) { //x的本身就在左方的边界，左方不存在任何东西，直接返回 return false; } if (chessMap[x][y] == comGain[i][j]) { winCount++; x--; } } if (winCount == comGain[i].length) { return true; } } return false; } } //检测棋盘上一个点的右方有多少个黑子 //y轴不变，x++ var rightAspect = function(x, y, flag, isNull, chessType) { var thisX = x; var thisY = y; //黑棋用户 if (chessType == 1) { for (var i = 0; i < myGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < myGain[i].length; j++) { if (x == 15) { return false; } if (chessMap[x][y] == myGain[i][j]) { winCount++; x++; } } if (winCount == myGain[i].length) { return true; } } return false; } else { for (var i = 0; i < comGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < comGain[i].length; j++) { if (x == 15) { return false; } if (chessMap[x][y] == comGain[i][j]) { winCount++; x++; } } if (winCount == comGain[i].length) { return true; } } return false; } } //检测棋盘上一个点的左上方有多少个黑子 // x-- y-- var upLeftAspect = function(x, y, flag, isNull, chessType) { var thisX = x; var thisY = y; //黑棋用户 if (chessType == 1) { for (var i = 0; i < myGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < myGain[i].length; j++) { if (x == -1 || y == -1) { return false; } if (chessMap[x][y] == myGain[i][j]) { winCount++; x--; y--; } } if (winCount == myGain[i].length) { return true; } } return false; } else { for (var i = 0; i < comGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < comGain[i].length; j++) { if (x == -1 || y == -1) { return false; } if (chessMap[x][y] == comGain[i][j]) { winCount++; x--; y--; } } if (winCount == comGain[i].length) { return true; } } return false; } } //检测棋盘上一个点的右上方有多少个黑子 //x++ y-- var rightUpAspect = function(x, y, flag, isNull, chessType) { var thisX = x; var thisY = y; //黑棋用户 if (chessType == 1) { for (var i = 0; i < myGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < myGain[i].length; j++) { if (x == 15 || y == -1) { return false; } if (chessMap[x][y] == myGain[i][j]) { winCount++; x++; y--; } } if (winCount == myGain[i].length) { return true; } } return false; } else { for (var i = 0; i < comGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < comGain[i].length; j++) { if (x == 15 || y == -1) { return false; } if (chessMap[x][y] == comGain[i][j]) { winCount++; x++; y--; } } if (winCount == comGain[i].length) { return true; } } return false; } } //检测棋盘上一个点的左下方有多少个黑子 //x-- y++ var leftDownAspect = function(x, y, flag, isNull, chessType) { var thisX = x; var thisY = y; //黑棋用户 if (chessType == 1) { for (var i = 0; i < myGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < myGain[i].length; j++) { if (x == -1 || y == 15) { return false; } if (chessMap[x][y] == myGain[i][j]) { winCount++; x--; y++; } } if (winCount == myGain[i].length) { return true; } } return false; } else { for (var i = 0; i < comGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < comGain[i].length; j++) { if (x == -1 || y == 15) { return false; } if (chessMap[x][y] == comGain[i][j]) { winCount++; x--; y++; } } if (winCount == comGain[i].length) { return true; } } return false; } } //检测棋盘上一个点的右下方有多少个黑子 //x++ y++ var rightDownAspect = function(x, y, flag, isNull, chessType) { var thisX = x; var thisY = y; //黑棋用户 if (chessType == 1) { for (var i = 0; i < myGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < myGain[i].length; j++) { if (x == 15 || y == 15) { return false; } if (chessMap[x][y] == myGain[i][j]) { winCount++; x++; y++; } } if (winCount == myGain[i].length) { return true; } } return false; } else { for (var i = 0; i < comGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < comGain[i].length; j++) { if (x == 15 || y == 15) { return false; } if (chessMap[x][y] == comGain[i][j]) { winCount++; x++; y++; } } if (winCount == comGain[i].length) { return true; } } return false; } } //绘制棋盘 var drawCheckerBoard = function() { for (var i = 0; i < LINE; i++) { chessPen.beginPath(); chessPen.moveTo(LINTTOPADDIN + i * LINE_SIZEPX, 0 + LINE); chessPen.lineTo(LINTTOPADDIN + i * LINE_SIZEPX, CHESS_HEIGTH - LINE); chessPen.stroke(); chessPen.beginPath(); chessPen.moveTo(0 + LINTTOPADDIN, LINTTOPADDIN + i * LINE_SIZEPX); chessPen.lineTo(CHESS_WIDTH - LINTTOPADDIN, LINTTOPADDIN + i * LINE_SIZEPX); chessPen.stroke(); } }; //绘制棋子 var drawOneChess = function(x, y, isBlack) { downChess.load(); //每次单击重新载入音频 downChess.play(); //单击播放音频 chessPen.beginPath(); chessPen.arc(LINTTOPADDIN + x * LINE_SIZEPX, LINTTOPADDIN + y * LINE_SIZEPX, 13, 0, 2 * Math.PI); chessPen.closePath(); var gradient = chessPen.createRadialGradient(LINTTOPADDIN + x * LINE_SIZEPX + 2, LINTTOPADDIN + y * LINE_SIZEPX - 2, 13, LINTTOPADDIN + x * LINE_SIZEPX + 2, LINTTOPADDIN + y * LINE_SIZEPX - 2, 0); if (isBlack) { gradient.addColorStop(0, \"#0A0A0A\"); gradient.addColorStop(1, \"#636766\"); } else { gradient.addColorStop(0, \"#D1D1D1\"); gradient.addColorStop(1, \"#F9F9F9\"); } chessPen.fillStyle = gradient; chessPen.fill(); };"},{"title":"","date":"2016-10-25T14:38:27.746Z","updated":"2014-07-14T06:16:52.711Z","comments":true,"path":"small/time/js/digit.js","permalink":"http://www.cheshen.wiki/small/time/js/digit.js","excerpt":"","text":"digit = [ [ [0,0,1,1,1,0,0], [0,1,1,0,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,0,1,1,0], [0,0,1,1,1,0,0] ],//0 [ [0,0,0,1,1,0,0], [0,1,1,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [1,1,1,1,1,1,1] ],//1 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,1,1,0,0,0], [0,1,1,0,0,0,0], [1,1,0,0,0,0,0], [1,1,0,0,0,1,1], [1,1,1,1,1,1,1] ],//2 [ [1,1,1,1,1,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,1,1,1,0,0], [0,0,0,0,1,1,0], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//3 [ [0,0,0,0,1,1,0], [0,0,0,1,1,1,0], [0,0,1,1,1,1,0], [0,1,1,0,1,1,0], [1,1,0,0,1,1,0], [1,1,1,1,1,1,1], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,1,1,1,1] ],//4 [ [1,1,1,1,1,1,1], [1,1,0,0,0,0,0], [1,1,0,0,0,0,0], [1,1,1,1,1,1,0], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//5 [ [0,0,0,0,1,1,0], [0,0,1,1,0,0,0], [0,1,1,0,0,0,0], [1,1,0,0,0,0,0], [1,1,0,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//6 [ [1,1,1,1,1,1,1], [1,1,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0] ],//7 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//8 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,1,1,0,0,0,0] ],//9 [ [0,0,0,0], [0,0,0,0], [0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0], [0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0] ]//: ];"},{"title":"","date":"2016-10-25T15:00:44.533Z","updated":"2016-10-25T15:00:44.533Z","comments":true,"path":"small/time/js/countdown.js","permalink":"http://www.cheshen.wiki/small/time/js/countdown.js","excerpt":"","text":"var WINDOW_WIDTH = 1024; //宽 var WINDOW_HEIGHT = 768; //高 var RADIUS = 8; //绘制每个数字小圆球的半径 var MARGIN_TOP = 60; //每一个数字距离画布上边距的距离 var MARGIN_LEFT = 30; //第一个数字距离画布的左边距的距离 const FRICTION = 0.65; //彩色小球弹跳起来时功的消耗 //在js中月份0代表1月 const endTime = new Date(2016, 2, 10, 18, 47, 52); //倒计时的时间 var curShowTimeSeconds = 0; //现在倒计时需要多少秒 var balls = []; //用来记录小球的数组 //用于生成滚动小球的颜色，随机抽取 const colors = [\"#33B5E5\", \"#0099CC\", \"#AA66CC\", \"#9933CC\", \"#99CC00\", \"#669900\", \"#FFBB33\", \"#FF8800\", \"#FF4444\", \"#CC0000\"]; //页面加载执行 window.onload = function () { //自适应处理 /** * 但是这样做得不到整个屏幕的宽度和高度，需要给body * 和canvas加一个style height=100% * @type {number} */ // WINDOW_WIDTH = document.body.clientWidth; // WINDOW_HEIGHT = document.body.clientHeight; /* 为了匹配博客的样式 -- start */ WINDOW_HEIGHT = document.body.clientHeight / 2; WINDOW_WIDTH = $(\".content-wrap\").width() /* 为了匹配博客的样式 -- end */ MARGIN_LEFT = Math.round(WINDOW_WIDTH / 10);//宽度是整个屏幕的十分之一 RADIUS = Math.round(WINDOW_WIDTH * 4 / 5 / 108)-1; MARGIN_TOP = Math.round(WINDOW_HEIGHT /5);//高度是整个屏幕的五分之一 var canvas = document.getElementById('canvas'); var context = canvas.getContext('2d'); canvas.width = WINDOW_WIDTH; canvas.height = WINDOW_HEIGHT; curShowTimeSeconds = getCurShowTimeSeconds(); /** * 动画的基本模型 */ setInterval(function () { //绘制当前的动画 render(context); //对当前数据进行调整 update(); }, 50); }; //当前时间和倒计时时间的秒数 function getCurShowTimeSeconds() { //倒计时效果 //var curTime = new Date(); //var ret = endTime.getTime() - curTime.getTime(); //ret = Math.round(ret / 1000); //return ret >= 0 ? ret : 0; //时钟效果 var curTime = new Date(); var ret = curTime.getHours() * 3600 + curTime.getMinutes() * 60 + curTime.getSeconds(); return ret; } //绘制方法 function render(ctx) { //对一个举行空间内的图形进行一次刷新操作 ctx.clearRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT); var hours = parseInt(curShowTimeSeconds / 3600); var minutes = parseInt((curShowTimeSeconds - hours * 3600) / 60); var seconds = curShowTimeSeconds % 60; //绘制小时的第一个数字 renderDigit(MARGIN_LEFT, MARGIN_TOP, parseInt(hours / 10), ctx); /** * 绘制小时的第二个数字 * 因为半径是8，实际上的距离是7 * 2 所以是 14 * （半径 + 1）的距离 * 为了留有一定的空隙，所以改成 15 * （半径 + 1） */ renderDigit(MARGIN_LEFT + 15 * (RADIUS + 1), MARGIN_TOP, parseInt(hours % 10), ctx); /** * 绘制冒号 * 一个数字是15 那么第二个数字是30 */ renderDigit(MARGIN_LEFT + 30 * (RADIUS + 1), MARGIN_TOP, 10, ctx); //绘制分钟，因为冒号占用的是4，4*2+1是9 renderDigit(MARGIN_LEFT + 39 * (RADIUS + 1), MARGIN_TOP, parseInt(minutes / 10), ctx); renderDigit(MARGIN_LEFT + 54 * (RADIUS + 1), MARGIN_TOP, parseInt(minutes % 10), ctx); //又一个冒号 renderDigit(MARGIN_LEFT + 69 * (RADIUS + 1), MARGIN_TOP, 10, ctx); //绘制秒数 renderDigit(MARGIN_LEFT + 78 * (RADIUS + 1), MARGIN_TOP, parseInt(seconds / 10), ctx); renderDigit(MARGIN_LEFT + 93 * (RADIUS + 1), MARGIN_TOP, parseInt(seconds % 10), ctx); //绘制彩色小球 for (var i = 0; i < balls.length; i++) { ctx.fillStyle = balls[i].color; ctx.beginPath(); ctx.arc(balls[i].x, balls[i].y, RADIUS, 0, 2 * Math.PI, true); ctx.closePath(); ctx.fill(); } } //绘制一个具体的数字 function renderDigit(x, y, num, ctx) { ctx.fillStyle = \"rgb(0,102,153)\"; for (var i = 0; i < digit[num].length; i++) { for (var j = 0; j < digit[num][i].length; j++) { if (digit[num][i][j] == 1) { ctx.beginPath(); ctx.arc( x + j * 2 * (RADIUS + 1) + (RADIUS + 1), y + i * 2 * (RADIUS + 1) + (RADIUS + 1), RADIUS, 0, 2 * Math.PI ); ctx.closePath(); ctx.fill(); } } } } //对当前数据进行调整 function update() { //得到下一次时间 var nextShowTimeSeconds = getCurShowTimeSeconds(); var nextHours = parseInt(nextShowTimeSeconds / 3600); var nextMinutes = parseInt((nextShowTimeSeconds - nextHours * 3600) / 60); var nextSeconds = nextShowTimeSeconds % 60; //得到当前时间 var curHours = parseInt(curShowTimeSeconds / 3600); var curMinutes = parseInt((curShowTimeSeconds - curHours * 3600) / 60); var curSeconds = curShowTimeSeconds % 60; //比较两个时间是不是已经变化的，实际上只用看秒数就可以了 if (curSeconds != nextSeconds) { //判断当前小时的十位数是不是不等于下一次小时的十位数 if (parseInt(curHours / 10) != parseInt(nextHours / 10)) { //成立则记录这个小球 addBalls(MARGIN_LEFT + 0, MARGIN_TOP, parseInt(curHours / 10)); } if (parseInt(curHours % 10) != parseInt(nextHours % 10)) { addBalls(MARGIN_LEFT + 15 * (RADIUS + 1), MARGIN_TOP, parseInt(curHours / 10)); } if (parseInt(curMinutes / 10) != parseInt(nextMinutes / 10)) { addBalls(MARGIN_LEFT + 39 * (RADIUS + 1), MARGIN_TOP, parseInt(curMinutes / 10)); } if (parseInt(curMinutes % 10) != parseInt(nextMinutes % 10)) { addBalls(MARGIN_LEFT + 54 * (RADIUS + 1), MARGIN_TOP, parseInt(curMinutes % 10)); } if (parseInt(curSeconds / 10) != parseInt(nextSeconds / 10)) { addBalls(MARGIN_LEFT + 78 * (RADIUS + 1), MARGIN_TOP, parseInt(curSeconds / 10)); } if (parseInt(curSeconds % 10) != parseInt(nextSeconds % 10)) { addBalls(MARGIN_LEFT + 93 * (RADIUS + 1), MARGIN_TOP, parseInt(nextSeconds % 10)); } //如果成立，就让当前时间等于下一次的时间 curShowTimeSeconds = nextShowTimeSeconds; } //更新所有的小球位置 updateBalls(); // console.log( balls.length); } //对所有的小球位置进行更新 function updateBalls() { //循环得到每一个小球 for (var i = 0; i < balls.length; i++) { balls[i].x += balls[i].vx; //小球的x轴加上x轴的速度值 balls[i].y += balls[i].vy; //小球的y轴加上y轴的速度值 balls[i].vy += balls[i].g; //小球在y轴的速度受到重力的影响 //对地板底部碰撞进行判断 if (balls[i].y >= WINDOW_HEIGHT - RADIUS) { balls[i].y = WINDOW_HEIGHT - RADIUS; //碰撞地板后小球的y轴位置就等于底部接触地板的坐标 balls[i].vy = -balls[i].vy * FRICTION; //小球每次弹起功耗的消耗情况 } } var cnt = 0; //记录还有个小球还在整个画布内 //清除已经不在屏幕上的小球，避免运行时间过长内存溢出 for (var i = 0; i < balls.length; i++) { //小球在X轴的位置，大于0，并且大于canvas画布的宽度，满足条件则说明在屏幕内 if(balls[i].x - RADIUS > 0 && balls[i].x-RADIUS < WINDOW_WIDTH){ //从0-cnt个小球，都是在屏幕内的小球 balls[cnt++] = balls[i]; } } //删除cnt后面的小球 //如果cnt大于300，也清空 while(balls.length > Math.min(500,cnt)){ balls.pop(); } } //添加一个彩色的小球 function addBalls(x, y, num) { for (var i = 0; i < digit[num].length; i++) { for (var j = 0; j < digit[num][i].length; j++) { if (digit[num][i][j] == 1) { var aBall = { x: x + j * 2 * (RADIUS + 1) + (RADIUS + 1), //x坐标 y: y + i * 2 * (RADIUS + 1) + (RADIUS + 1), //y坐标 g: 1.5 + Math.random(), //重力加速度，随机产生1.5 - 2.5的速度让小球有所不同 //小球在X轴的速度，0 - 1 随机数 乘 1000 用 ceil 取整 //如果取整结果为偶数为+1，如果为负数则为-1，最后乘4，速度为+4或-4. vx: Math.pow(-1, Math.ceil(Math.random() * 1000)) * 4, vy: -5, //小球在y轴有一个上抛的动作 //随机小球的颜色，用0-1随机数，乘以 coolors 的length //用下取整函数floor求出0-10 不包含10的随机数 color: colors[Math.floor(Math.random() * colors.length)] } balls.push(aBall); } } } }"}],"posts":[{"title":"Ubuntu安装postgresql","slug":"Ubuntu安装postgresql","date":"2017-03-29T14:49:10.000Z","updated":"2017-03-29T14:57:41.541Z","comments":true,"path":"2017/03/29/Ubuntu安装postgresql/","link":"","permalink":"http://www.cheshen.wiki/2017/03/29/Ubuntu安装postgresql/","excerpt":"环境：Ubuntu-16.04-64bit 首先更换中科大的Ubuntu源： 网址：https://mirrors.ustc.edu.cn/help/ubuntu.html","text":"环境：Ubuntu-16.04-64bit 首先更换中科大的Ubuntu源： 网址：https://mirrors.ustc.edu.cn/help/ubuntu.html 直接编辑 /etc/apt/sources.list 文件（需要使用 sudo）。以下是 Ubuntu 16.04 参考配置内容： 12345678910111213# 默认注释了源码仓库，如有需要可自行取消注释deb https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial main main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse 参考命令： 注意是在/etc/apt/目录下，一下命令都要使用root账户操作，或加sudo。 mv sources.list sources.list.back vim sources.list 然后粘贴上面的内容 apt-get update 一切无误没有报错继续进行，报错先排查错误，不行就把sources.list.back文件重新恢复回去。 apt-get install postgresql 稍等一会，提示安装完成： 输入 sudo -i -u postgres psql 然后进入postgresql的命令行界面 看到命令行显示postgres=#，说明我们进入了postgresql的命令行界面 接着输入 \\password postgres 提示我们输入一个新的密码 Enter new password: 随便输入你的密码Enter it again: 再次输入你的密码 回车以后就可以了 然后输入\\q退出命令行界面，再输入exit退出到系统用户界面。 接着可以在windows上安装Python项目所需要的依赖，首先新建虚拟环境： 123virtualenv --no-site-packages --python=C:\\Dream\\Python\\Python27\\python.exe xuemc如果没有安装virtualenv，需要先进行安装：pip install virtualenv 使用pip安装项目依赖的环境： pip install -r requirement.txt -i https://pypi.doubanio.com/simple/ 此处我们使用豆瓣的镜像，速度会提升很多 如果在Linux安装过程中报错，请尝试安装下面的依赖包 sudo apt-get install libxml2-dev libxslt1-dev python-dev sudo apt-get install libpq-dev sudo apt-get install libxml2 sudo apt-get install libjpeg-dev 如果还不行，可以自行查找错误","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.cheshen.wiki/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.cheshen.wiki/tags/Linux/"},{"name":"postgresql","slug":"postgresql","permalink":"http://www.cheshen.wiki/tags/postgresql/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://www.cheshen.wiki/categories/Linux/"}]},{"title":"Linux 进程管理工具：supervisor","slug":"Linux 进程管理工具：supervisor","date":"2017-03-29T14:49:10.000Z","updated":"2017-03-29T14:49:48.876Z","comments":true,"path":"2017/03/29/Linux 进程管理工具：supervisor/","link":"","permalink":"http://www.cheshen.wiki/2017/03/29/Linux 进程管理工具：supervisor/","excerpt":"supervisor简介在Linux服务器中，有时候我们需要一个进程需要可靠的在后台运行，并且能够监控进程状态，在意外结束时能够自动重启等。此时就可以使用supervisor。 supervisor 是使用Python开发的一套通用的进程管理程序，能够将一个普通的命令行进程变成后台的守护进程，并且监控进程的状态，异常退出时能够自动重启。","text":"supervisor简介在Linux服务器中，有时候我们需要一个进程需要可靠的在后台运行，并且能够监控进程状态，在意外结束时能够自动重启等。此时就可以使用supervisor。 supervisor 是使用Python开发的一套通用的进程管理程序，能够将一个普通的命令行进程变成后台的守护进程，并且监控进程的状态，异常退出时能够自动重启。 安装supervisor在Ubuntu中可以使用apt-get来安装： 1sudo apt-get install supervisor 如果安装缓慢，可以更换中科大的源： https://mirrors.ustc.edu.cn/help/ubuntu.html 配置安装完成以后，我们需要编写一个配置文件，让supervisor来管理它。每个进程的配置文件都可以单独拆分，放在/etc/supervisor/conf.d/目录下，以.conf作为扩展名。 1234# 首先进入/etc/supervisor/conf.d目录/etc/supervisor/conf.d# 使用supervisor自带的命令生成模板echo_supervisord_conf &gt; foo.conf 编辑模板，在开头添加以下内容： 12[program:foo]command=/bin/cat [program:app] ： 定义进程app command ： 命令 directory ： 进程的当前目录 user ： 进程运行的用户身份 详细配置说明： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071;*为必须填写项;*[program:应用名称][program:cat];*命令路径,如果使用python启动的程序应该为 python /home/test.py, ;不建议放入/home/user/, 对于非user用户一般情况下是不能访问command=/bin/cat;当numprocs为1时,process_name=%(program_name)s;当numprocs&gt;=2时,%(program_name)s_%(process_num)02dprocess_name=%(program_name)s;进程数量numprocs=1;执行目录,若有/home/supervisor_test/test1.py;将directory设置成/home/supervisor_test;则command只需设置成python test1.py;否则command必须设置成绝对执行目录directory=/tmp;掩码:--- -w- -w-, 转换后rwx r-x w-xumask=022;优先级,值越高,最后启动,最先被关闭,默认值999priority=999;如果是true,当supervisor启动时,程序将会自动启动autostart=true;*自动重启autorestart=true;启动延时执行,默认1秒startsecs=10;启动尝试次数,默认3次startretries=3;当退出码是0,2时,执行重启,默认值0,2exitcodes=0,2;停止信号,默认TERM;中断:INT(类似于Ctrl+C)(kill -INT pid),退出后会将写文件或日志(推荐);终止:TERM(kill -TERM pid);挂起:HUP(kill -HUP pid),注意与Ctrl+Z/kill -stop pid不同;从容停止:QUIT(kill -QUIT pid);KILL, USR1, USR2其他见命令(kill -l),说明1stopsignal=TERMstopwaitsecs=10;*以root用户执行user=root;重定向redirect_stderr=falsestdout_logfile=/a/pathstdout_logfile_maxbytes=1MBstdout_logfile_backups=10stdout_capture_maxbytes=1MBstderr_logfile=/a/pathstderr_logfile_maxbytes=1MBstderr_logfile_backups=10stderr_capture_maxbytes=1MB;环境变量设置environment=A=&quot;1&quot;,B=&quot;2&quot;serverurl=AUTO 启动如果编辑默认的supervisor.conf，则需要重启supervisor使配置文件生效： 1supervisorctl reload 然后运行下面的命令启动进程： 1supervisorctl start foo 如果运行出现如下错误： 1unix:///var/run/supervisor.sock no such file 可以运行下面的命令，然后再次启动： sudo touch /var/run/supervisor.socksudo chmod 777 /var/run/supervisor.socksudo service supervisor restart 看到如下信息，说明运行成功： foo: started 也可以输入12345678910&gt; foo RUNNING pid 6665, uptime 0:08:08在supervisor的控制台输入help可以获取帮助信息，输入status可以获取当前运行的进程信息，输入exit可以退出supervisor的控制台界面。## 关闭使用下面的命令就可以关闭supervisor启动的进程： supervisorctl stop foo123456789101112可以看到输出信息：&gt; foo: stopped## 常用命令&gt;更新新的配置到supervisord&gt;&gt; supervisorctl update1234&gt;&gt;重新启动配置中的所有程序&gt;&gt; supervisorctl reload 1234&gt;&gt;启动某个进程(program_name=你配置中写的程序名称)&gt;&gt; supervisorctl start program_name 1234&gt;&gt;查看正在守候的进程(同时进入控制台)&gt;&gt; supervisorctl 1234&gt;&gt;停止某一进程 (program_name=你配置中写的程序名称)&gt;&gt; pervisorctl stop program_name 1234&gt;&gt;重启某一进程 (program_name=你配置中写的程序名称)&gt;&gt; supervisorctl restart program_name 1234&gt;&gt;停止全部进程&gt;&gt; supervisorctl stop all``` 更多内容可以参考：supervisor官方文档","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.cheshen.wiki/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.cheshen.wiki/tags/Linux/"},{"name":"supervisor","slug":"supervisor","permalink":"http://www.cheshen.wiki/tags/supervisor/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://www.cheshen.wiki/categories/Linux/"}]},{"title":"Python装饰器进阶之一","slug":"Python装饰器进阶之一","date":"2017-03-12T10:22:31.000Z","updated":"2017-03-29T14:51:02.640Z","comments":true,"path":"2017/03/12/Python装饰器进阶之一/","link":"","permalink":"http://www.cheshen.wiki/2017/03/12/Python装饰器进阶之一/","excerpt":"先看例子网上有很多装饰器的文章，上来说半天也没让人看明白装饰器到底是个什么，究竟有什么用，我们直接来看几个例子。 Python递归求斐波那契数列 12345def fibonacci(n): if n &lt;= 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2)print(fibonacci(50)) 这是一个很常见的求斐波那契数列的例子，但是这其中有非常多的重复计算。","text":"先看例子网上有很多装饰器的文章，上来说半天也没让人看明白装饰器到底是个什么，究竟有什么用，我们直接来看几个例子。 Python递归求斐波那契数列 12345def fibonacci(n): if n &lt;= 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2)print(fibonacci(50)) 这是一个很常见的求斐波那契数列的例子，但是这其中有非常多的重复计算。 如：我们要计算第10位数字是多少，就要先计算出第9位数字是多少，并且是从0计算到9。此时我们已经计算过0-9位数字的值，甚至已经知道第10位数字的值，但是当计算第11位的时候却又要重复一遍。也就是说我们如果计算第50位数字是多少，就要先计算0-1,0-2,0-3 … 0-48,0-49,0-50。数字越大，重复的计算就越多。上面的程序有兴趣的可以运行一下，我等待了五分钟没有出结果就强行在任务管理器关闭了。 略微修改一下 12345678910111213141516# 增加一个缓存字典def fibonacci(n, cache=None): # 第一次没有任何缓存，初始化字典 if cache is None: cache = &#123;&#125; # 如果n这个数字，是我们已经计算过的，就不需要再去递归从头计算了 if n in cache: return cache[n] if n &lt;= 1: return 1 # 如果缓存没有，就把它增加到缓存中去 cache[n] = fibonacci(n - 1, cache) + fibonacci(n - 2, cache) return cache[n]print(fibonacci(50)) 运行结果： 20365011074[Finished in 0.1s] 前面运行五分钟没有任何结果，而简单修改以后仅仅用了0.1秒，可见重复计算对性能的影响用几何倍数称呼都不为过。 思考： 这种重复计算的问题，在我们的项目中是非常常见的，特别是一些计算概率的方法，都需要重复计算。那么我们总不能每个方法都这样改写一次吧？那样我们的项目中会包含大量的冗余代码，不利于我们的维护，也违背了我们高内聚，低耦合的编程思想。那我们能否实现，只用写一个增加缓存的方法，然后其他的方法我们都使用这个方法来装饰它，让它拥有这个功能。 实现思路： 写一个方法假设方法名为add_cache，该方法拥有缓存 add_cache接收一个参数，参数就是原方法的对象 在add_cache方法内部，有一个wrap方法，该方法就接收原来fibonacci方法的参数 wrap方法首先判断参数是否在缓存中，如果在，就直接返回缓存中的值 如果不在缓存中就调用原来的fibonacci方法计算然后把值保存在缓存中 在add_cache中返回新的wrap方法的对象 举个栗子 12345678910111213141516171819202122232425262728# 装饰方法def add_cache(func): cache = &#123;&#125; # 因为方法可能不是都只有一个参数，所以我们使用这种形式可以接收任意个参数 # wrap可以随便起名的，还有add_cache都是随便起名字不是固定的 def wrap(*args): # 如果这些参数不在cache中 if args not in cache: # 调用原方法，并且把这些参数对应的值存储在cache中 # 需要注意的是，传递给原方法我们要把元组形式的args拆分成单个参数 cache[args] = func(*args) # 在cache中就直接返回 return cache[args] # 我们需要把新的方法对象返回回去，这样用户调用add_cache传递旧的方法就能得到新的方法对象 return wrap# 计算斐波那契的方法def fibonacci(n): if n &lt;= 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2)\"\"\" 调用装饰方法，获得新的增加了功能的对象，通常新方法名保持和原方法名一致，这样原来的业务逻辑不需要做任何修改\"\"\"fibonacci = add_cache(fibonacci)# 需要注意的是，Python的数值也是有长度限制的，在Win10x64计算机上，最高可以计算第332位print(fibonacci(50)) 看完上面的例子以后，有人可能会说：这不是忽悠人呢？你以为我是新手啊，不知道什么是装饰器吗？装饰器我看人家都是用@符号后面跟个名字，然后写在方法上就可以了。 我想说，之所以能够实现@符号装饰，是因为Python给我们提供了这样的便利，再来看上面的例子： 12345678910111213141516def add_cache(func): cache = &#123;&#125; def wrap(*args): if args not in cache: cache[args] = func(*args) return cache[args] return wrap# 装饰fibonacci方法，只用一个@符号，后跟自己写的装饰方法即可@add_cachedef fibonacci(n): if n &lt;= 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2)# 此时这个fibonacci实际上已经被增加了新的功能print(fibonacci(50)) 同样能够实现之前的功能。 提醒：我之所以不厌其烦的复制重复代码，并且一行一行删除掉已经写过的注释，就是希望能加深大家的印象，能把别处学来的东西，真正理解，应用到工作中，变成自己的东西。 至此，我相信大家已经明白什么是装饰器了。所谓装饰器，就是给我们原来非常单调，没有某些功能的方法，增加一些功能，就跟我们玩游戏给人物带装备一样。这么想是不是非常容易理解了。 代码我在Python2.x和3.x都测试过没问题 废话不想说那么多，希望大家好好学习，工资蹭蹭往上涨。 by. 秋名山车神 END","categories":[{"name":"装饰器","slug":"装饰器","permalink":"http://www.cheshen.wiki/categories/装饰器/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.cheshen.wiki/tags/Python/"},{"name":"装饰器","slug":"装饰器","permalink":"http://www.cheshen.wiki/tags/装饰器/"}],"keywords":[{"name":"装饰器","slug":"装饰器","permalink":"http://www.cheshen.wiki/categories/装饰器/"}]},{"title":"Python多线程----线程池","slug":"Python多线程----线程池","date":"2017-03-12T10:21:05.000Z","updated":"2017-03-29T14:49:25.713Z","comments":true,"path":"2017/03/12/Python多线程----线程池/","link":"","permalink":"http://www.cheshen.wiki/2017/03/12/Python多线程----线程池/","excerpt":"需求：假设我们现在有一个多线程项目，每有一个用户连接进来，我们的服务器就会创建一个线程。而我们的服务器最多能够承载100个线程，再多就会崩溃。为了防止恶意用户伪装真实用户构建大量的访问来让我们的服务器崩溃，现在需要对线程数量进行限制，一共只有100个线程，并且当一个用户访问结束以后线程会自动归还，等待下一个用户访问。如果100个线程全部被占用则101个用户进入阻塞时间，直到某一个用户退出，线程得到释放，101个用户才能被通行。","text":"需求：假设我们现在有一个多线程项目，每有一个用户连接进来，我们的服务器就会创建一个线程。而我们的服务器最多能够承载100个线程，再多就会崩溃。为了防止恶意用户伪装真实用户构建大量的访问来让我们的服务器崩溃，现在需要对线程数量进行限制，一共只有100个线程，并且当一个用户访问结束以后线程会自动归还，等待下一个用户访问。如果100个线程全部被占用则101个用户进入阻塞时间，直到某一个用户退出，线程得到释放，101个用户才能被通行。 不难看出上面的需求，类似我们MySQL的连接池。既然如此，我们的Python也应该有一个线程池，并且这种问题非常的常见，肯定已经有现成的库以供我们使用。今天我们就来看一下Python标准库中from concurrent.futures下的ThreadPoolExecutor。 第一个例子 123456789101112131415# 首先导包from concurrent.futures import ThreadPoolExecutor# 创建线程池executor = ThreadPoolExecutor(10)# 测试方法def test_function(num1, num2): print(num1, num2) return num1 + num2# 第一个参数为具体的方法，后面为方法的参数future = executor.submit(test_function, 1, 2)# future的result()方法可以获取到函数的执行结果print(future.result()) 执行结果： 1 23 ThreadPoolExecutor(pool_count): pool_count代表创建线程的数量，会返回一个该线程池的执行者对象，这个对象的submit()方法和map()方法，能够使用线程池中的线程来执行我们指定的方法，并且返回一个Future对象。Future对象的result()方法，可以获取我们方法执行的结果。如果方法一直没有返回或执行完毕，则result()方法会进入阻塞状态，直到我们的方法返回或执行完毕。 使用map()方法批量执行 1234567891011121314151617181920212223from concurrent.futures import ThreadPoolExecutorexecutor = ThreadPoolExecutor(10)def test_function(num1, num2): print(num1, num2) return num1 + num2\"\"\" executor.map(function, 参数1_list, 参数2_list, 参数n_list) 参数1_list: 代表方法第一个参数的列表 参数2_list: 代表方法第二个参数的列表 如： executor.map(test_function, [1, 2], [5, 5]) 代表，执行test_function方法，第一个线程的参数为1和5，第二个线程的参数为2和5。 线程1：test_function(1, 5) 结果为1 + 5 = 6 该方法返回的是一个可迭代的对象，里面直接包含了每个方法执行的结果，不需要调用result()方法。 详情：https://docs.python.org/3/library/concurrent.futures.html\"\"\"result_iterators = executor.map(test_function, [1, 2], [5, 5])for result in result_iterators: print(result) 执行结果： 1 52 567 尝试一下所有线程都被占用的情况 12345678910111213141516171819202122import timefrom concurrent.futures import ThreadPoolExecutor# 方便测试创建三个线程executor = ThreadPoolExecutor(3)def test_function(num1, num2): print(num1, num2) # 方法休眠十秒 time.sleep(10) return num1 + num2# 使用三个线程，占用线程池全部线程# 由于我们的结果是十秒后返回，所以这里也会被阻塞，十秒后才会收到结果result_iterators = executor.map(test_function, [1, 2, 3], [5, 6, 7])for result in result_iterators: print(result)# 到这里很显然前面三个线程都在使用中，10秒后才能得到执行future = executor.submit(test_function, 4, 8)print(future.result()) 执行结果： 1 52 63 768104 812[Finished in 20.2s]","categories":[{"name":"多线程","slug":"多线程","permalink":"http://www.cheshen.wiki/categories/多线程/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"http://www.cheshen.wiki/tags/线程池/"},{"name":"Python","slug":"Python","permalink":"http://www.cheshen.wiki/tags/Python/"},{"name":"多线程","slug":"多线程","permalink":"http://www.cheshen.wiki/tags/多线程/"}],"keywords":[{"name":"多线程","slug":"多线程","permalink":"http://www.cheshen.wiki/categories/多线程/"}]},{"title":"Python装饰器进阶之二","slug":"Python装饰器进阶之二","date":"2017-03-12T10:21:05.000Z","updated":"2017-03-29T14:51:07.410Z","comments":true,"path":"2017/03/12/Python装饰器进阶之二/","link":"","permalink":"http://www.cheshen.wiki/2017/03/12/Python装饰器进阶之二/","excerpt":"保存被装饰方法的元数据什么是方法的元数据 举个栗子 1234def hello(): print('Hello, World.')print(dir(hello))","text":"保存被装饰方法的元数据什么是方法的元数据 举个栗子 1234def hello(): print('Hello, World.')print(dir(hello)) 结果如下： 1['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__'] 其中： 1234567__name__: 代表方法的名字__doc__: 代表方法的字符串文档(实际上就是&quot;&quot;&quot;...&quot;&quot;&quot;这种形式的注释)__moudle__: 方法所属模块的名字__dict__: 属性字典(这个属性在面向对象编程时很重要，用好了能大大节约Python内存的开支)__defaults__: 方法参数中，默认参数的值(实际上Python方法的默认参数是创建方法对象的时候就存储在这里的)...等等 以下面一个为例： 123456789101112def hello(numa, numb=1, numc=[]): \"\"\" Print numa, numb, numc. \"\"\" print(numa, numb, numc) return Trueprint(hello.__name__)print(hello.__doc__)print(hello.__module__)print(hello.__dict__)print(hello.__defaults__) 结果如下： 12345678hello Print numa, numb, numc. __main__&#123;&#125;(1, [])[Finished in 0.1s] 我们可以看到，123456789我们给方法增加一个属性：```pythondef hello(): print(&apos;Hello, World.&apos;)hello.name = &apos;XiaoMing&apos;print(hello.__dict__) 结果如下： 1&#123;&apos;name&apos;: &apos;XiaoMing&apos;&#125; 甚至我们还可以这样： 12345def hello(): print('Hello, World.')hello.__dict__['name'] = 'XiaoMing'print(hello.name) 结果如下： 1XiaoMing 同样的，我们的12345678```pythondef hello(numa, numb=1, numc=[]): print(numa, numb, numc)# 一共两个元素，下标1的元素就代表了我们的numc所对应的列表hello.__defaults__[1].append(&apos;Hello&apos;)hello(100) 结果如下： 1100 1 [&apos;Hello&apos;] 所以，在我们方法的默认参数上面，应该避免使用数组这种可变类型的数据结构。因为Python本身把1234567891011121314151617181920212223242526272829303132说了这么多废话，没有进入主题，来看装饰器对方法元数据的影响，上一章的例子：```pythondef add_cache(func): &quot;&quot;&quot; This add_cache &quot;&quot;&quot; cache = &#123;&#125; def wrap(*args): &quot;&quot;&quot; This wrap &quot;&quot;&quot; if args not in cache: cache[args] = func(*args) return cache[args] return wrap@add_cachedef fibonacci(n): &quot;&quot;&quot; This fibonacci &quot;&quot;&quot; if n &lt;= 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2)# 实际上返回的对象是wrap方法的对象，所以得到的也是wrap方法的元数据print(fibonacci.__name__)print(fibonacci.__doc__) 结果如下： 123wrap This wrap 如何保存被装饰方法的元数据不被改变这样就存在一个问题，我们的方法被装饰以后，原来的某些东西，我们无法访问了，这肯定是不行的，那我们必须想办法能够在装饰以后还保持某些元数据是原来方法的元数据。 简单思考以后我们可以这样做： 12345678910111213141516171819202122232425262728def add_cache(func): \"\"\" This add_cache \"\"\" cache = &#123;&#125; def wrap(*args): \"\"\" This wrap \"\"\" if args not in cache: cache[args] = func(*args) return cache[args] # 返回之前，我们修改这个对象的元数据让它等于原方法的元数据 wrap.__name__ = func.__name__ wrap.__doc__ = func.__doc__ return wrap@add_cachedef fibonacci(n): \"\"\" This fibonacci \"\"\" if n &lt;= 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2)print(fibonacci.__name__)print(fibonacci.__doc__) 结果和我们设想的一样： 123fibonacci This fibonacci 虽然是实现了我们的目的，但是这么做非常的不优雅，有没有比较优雅的做法呢。 我们可以使用Python标准库functools下的update_wrapper来实现： 123456789101112131415161718192021222324252627282930from functools import update_wrapperdef add_cache(func): \"\"\" This add_cache \"\"\" cache = &#123;&#125; def wrap(*args): \"\"\" This wrap \"\"\" if args not in cache: cache[args] = func(*args) return cache[args] # 使用update_wrapper来进行替换 update_wrapper(wrap, func, assigned=('__name__',), updated=('__dict__',)) return wrap@add_cachedef fibonacci(n): \"\"\" This fibonacci \"\"\" if n &lt;= 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2)print(fibonacci.__name__)print(fibonacci.__doc__) 结果如下： 123fibonacci This wrap 解析： 123456789101112131415update_wrapper: 第一个参数：代表装饰方法 第二个参数：代表被装饰方法 assigned：代表那些属性是需要替换的，不写的就代表不替换。(可以省略不写assigned=) updated：代表哪些属性需要合并，因为原方法有一些属性，装饰方法也有一些属性，所以他们两个里面的内容，需要合并在一起。(同样可以省略不写updated=)需要注意的是呢，update_wrapper中的assigned和updated都有一个默认的参数，来看一下这个方法的源代码：WRAPPER_ASSIGNMENTS = (&apos;__module__&apos;, &apos;__name__&apos;, &apos;__qualname__&apos;, &apos;__doc__&apos;, &apos;__annotations__&apos;)WRAPPER_UPDATES = (&apos;__dict__&apos;,)def update_wrapper(wrapper, wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES):所以，即使我们不指定后两个参数，也是可以实现我们的需求的。 还有一种更方便的做法，Python为我们提供了一个装饰器：1234567891011121314151617181920212223242526272829303132```pythonfrom functools import wrapsdef add_cache(func): &quot;&quot;&quot; This add_cache &quot;&quot;&quot; cache = &#123;&#125; # 使用装饰器来保存被装饰方法的元数据 @wraps(func) def wrap(*args): &quot;&quot;&quot; This wrap &quot;&quot;&quot; if args not in cache: cache[args] = func(*args) return cache[args] return wrap@add_cachedef fibonacci(n): &quot;&quot;&quot; This fibonacci &quot;&quot;&quot; if n &lt;= 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2)print(fibonacci.__name__)print(fibonacci.__doc__) 结果如下： 123fibonacci This fibonacci 实际上在@wraps()这个装饰器内部，使用的就是update_wrapper()方法。 END","categories":[{"name":"装饰器","slug":"装饰器","permalink":"http://www.cheshen.wiki/categories/装饰器/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.cheshen.wiki/tags/Python/"},{"name":"装饰器","slug":"装饰器","permalink":"http://www.cheshen.wiki/tags/装饰器/"}],"keywords":[{"name":"装饰器","slug":"装饰器","permalink":"http://www.cheshen.wiki/categories/装饰器/"}]},{"title":"Python多线程之threading.Thread","slug":"Python多线程之threading.Thread","date":"2017-03-12T10:21:05.000Z","updated":"2017-03-29T14:51:12.615Z","comments":true,"path":"2017/03/12/Python多线程之threading.Thread/","link":"","permalink":"http://www.cheshen.wiki/2017/03/12/Python多线程之threading.Thread/","excerpt":"并行和串行串行所谓串行，就好比我们走路一样，一条马路，一次只能过一辆车，这样速度就会很受限制。 并行理解了串行，并行就更好理解了，就是好多条路。路越多，车流量就越大。","text":"并行和串行串行所谓串行，就好比我们走路一样，一条马路，一次只能过一辆车，这样速度就会很受限制。 并行理解了串行，并行就更好理解了，就是好多条路。路越多，车流量就越大。 多线程就是并行的一种。当然，实际发生在计算机内部的时候，并不能单纯的理解为多了一条路。因为我们的计算机一个CPU核心，同时只能处理一个任务。在CPU只有一个核心的情况下，多线程我们就可以理解为开辟出了许多条道路，但是我们的出口只有一个。每条路上面的车都会你争我抢谁也不让，哪条路抢到了通行权这条路上的汽车就会赶快通过，直到下条路抢到通行权，其他路上的汽车都会进入等待状态。实际发生在计算机内部的时候，线程之间的切换都是毫秒级的，所以人的无法感觉出来线程之间有等待的，在人看来所有的线程都是同时运行的。使用多线程，可以大大的增加程序的性能和效率。 Python标准库threading.Thread线程创建1. 使用Thread类创建123456# 导入Python标准库中的Thread模块from threading import Thread# 创建一个线程t = Thread(target=function_name, args=(function_parameter1, function_parameterN))# 启动刚刚创建的线程t.start() function_name: 需要线程去执行的方法名 args: 线程执行方法接收的参数，该属性是一个元组，如果只有一个参数也需要在末尾加逗号。 2. 使用继承类创建123456789101112131415161718from threading import Thread# 创建一个类，必须要继承Threadclass MyThread(Thread): # 继承Thread的类，需要实现run方法，线程就是从这个方法开始的 def run(self): # 具体的逻辑 function_name(self.parameter1) def __init__(self, parameter1): # 需要执行父类的初始化方法 Thread.__init__(self) # 如果有参数，可以封装在类里面 self.parameter1 = parameter1# 如果有参数，实例化的时候需要把参数传递过去t = MyThread(parameter1)# 同样使用start()来启动线程t.start() 线程等待在上面的例子中，我们的主线程不会等待子线程执行完毕再结束自身。可以使用Thread类的join()方法来子线程执行完毕以后，主线程再关闭。 1234567891011121314from threading import Threadclass MyThread(Thread): def run(self): function_name(self.parameter1) def __init__(self, parameter1): Thread.__init__(self) self.parameter1 = parameter1t = MyThread(parameter1)t.start()# 只需要增加一句代码t.join() 上面的方法只有一个线程，如果有多个线程，可以把每个线程放在一个数组中。 123456789thread_list = []for i in range(1, 11): t = MyThread(parameter1) thread_list.append(t) t.start()# 在这里统一执行线程等待的方法for t in thread_list: t.join() CPU密集型操作和IO密集型操作CPU密集型操作在我们的计算机中，需要大量用到CPU计算的事情，我们称为CPU密集型操作。 如，我们计算9的一亿次方，这种大型的运算，或者是进行文件格式的转换，这些都是属于CPU密集型操作。 注意：上面的运算会消耗很长的计算时间，有兴趣可以从小到大慢慢尝试一下 IO密集型操作所谓IO密集型操作，就是涉及到大量的输入输出，比如频繁的数据库访问，频繁的web服务器访问，这种情况都属于IO密集型操作。 不幸的GIL线程同步我们都知道，多线程最大的一个问题就是线程之间的数据同步问题。在计算机发展过程中，各个CPU厂商，为了提升自己的性能，引入了多核概念。但是多个核心之间如果做到数据同步让所有人都花费了很多的时间和金钱，甚至最后消耗了CPU很多的性能才得以实现。 Python是如何做的？了解Python的朋友都知道，Python默认的实现是CPython，而CPython使用的是C语言的解释器。而由于历史原因，CPython中不幸的拥有了一个在未来非常影响Python性能的因素，那就是GIL。GIL全称Interpreter Lock```，又叫全局解释器锁。GIL是[计算机程序设计语言](http://baike.baidu.com/view/2561555.htm)[解释器](http://baike.baidu.com/view/592974.htm)用于[同步](http://baike.baidu.com/view/54180.htm)[线程](http://baike.baidu.com/view/1053.htm)的工具，而CPython中正是支持了GIL的特性，使得Python的解释器同一时间只能有一条线程运行，一直等到这个线程执行完毕释放了全局锁以后，才能有其他的线程来执行。也就是说，CPython本身实际上是一个单线程语言，甚至在多核CPU上面使用CPython的多线程反而性能不如单线程高。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273人们对于GIL还存在很大的误解，GIL只存在于Python中的CPython，使用Jython或者PyPy则不存在这个问题。&gt; - Python的线程是操作系统线程。在Linux上为pthread，在Windows上为Win thread，完全由操作系统调度线程的执行。一个python解释器进程内有一条主线程，以及多条用户程序的执行线程。即使在多核CPU平台上，由于GIL的存在，所以禁止多线程的并行执行。&gt; - Python解释器进程内的多线程是合作多任务方式执行。当一个线程遇到I/O任务时，将释放GIL。计算密集型（CPU-bound）的线程在执行大约100次解释器的计步（ticks）时，将释放GIL。计步（ticks）可粗略看作Python虚拟机的指令。计步实际上与时间片长度无关。可以通过sys.setcheckinterval()设置计步长度。&gt; - 在单核CPU上，数百次的间隔检查才会导致一次线程切换。在多核CPU上，存在严重的线程颠簸（thrashing）。#### 为什么CPython中使用了GIL我们都知道计算机一开始只是单核的，在那个年代人们并不会想到多核这种情况，于是为了应对多线程的数据同步问题，人们发明了锁。但是如果自己来写一个锁，不仅耗时耗力，而且还会隐藏许多未知的BUG等问题。于是在这样的大背景下，Python社区选择了最简单粗暴的方式，实现GIL，这样做有以下几点好处：&gt; 1. 可以增加单线程程序的运行速度（不再需要对所有数据结构分别获取或释放锁）&gt; 2. 容易和大部分非线程安全的 C 库进行集成&gt; 3. 容易实现（使用单独的 GIL 锁要比实现无锁，或者细粒度锁的解释器更容易）但是令Python社区没想到的是，CPU乃至计算机发展的如此迅速，双核，四核，甚至多CPU计算机的出现，让Python在很长一段时间内背负着运行效率低下的称号。而当Python社区和众多的Python库作者回过头想修改这些问题的时候却发现，代码与代码之间牢牢的依赖于GIL，面对庞大的绕成一团的线，也只能抽丝剥茧般的慢慢剔除。#### Python的新生值得庆幸的是，虽然我们不知道这一过程用了多久，但是在Python3.2中开始使用了全新的GIL，将大大的提升CPython的性能。#### 那Python3.2以下版本的多线程有什么用？很多人提到Python就想到爬虫，因为爬虫在某些程度上来说，Python的缺点完全不存在，而且还成了优点。我们来分析一下爬虫的运行过程：&gt; 1. 发送请求&gt; 2. 等待服务器响应&gt; 3. 收到服务器响应数据&gt; 4. 解析我们来看一下，以当前的计算机配置来说，对爬虫获取到的数据来进行解析处理的话，可能只需要几毫秒甚至更短的时间就能完成。那么一个爬虫程序最影响性能的地方在哪里？是IO操作。没错，我们的爬虫发出请求以后要等待对方的服务器来响应，这一过程是最耗时的，有时可能会需要一两秒的时间。此时，我们就可以在请求发送出去以后，立刻释放我们的全局锁，然后让下一个线程执行。直到某一个线程的响应回来以后消耗几毫秒处理数据，然后再次开始发送请求，而由于同一时间只有一条线程运行不需要考虑其他的问题，所以性能也会大大的提升。及时在爬虫上使用了真正意义的多线程，无非就是在解析数据的时候多几个线程来处理罢了。那么0.2毫秒和0.02毫秒，乃至无限至今于0毫秒的时间，他们之间的区别又是什么呢？同样都是人类无法分辨出来的差距，而我们又要对线程进行大量的安全性的处理，得不偿失。### 线程间通信在了解了线程以后，我们可能需要在多个线程之间通信。实现这一点，我们可以声明一个全局的存储对象，所有的线程都调用这一个对象来进行数据的存和取，这样就可以做到线程间的通信。我们使用传统的列表或元组都是可以的，但是列表和元组他们都是线程不安全的存储结构，我们需要自己加锁来保证线程安全。或者我们可以直接使用Python内置的线程安全的存储结构，Queue。Queue的使用如下：```python# Python2.xfrom Queue import Queue# Python3.ximport queue# Python2.xq = Queue()# Python3.xq = queue.Queue()# 存储一个元组到Queue中q.put((1, &apos;a&apos;))# q.get()每次获取一个数据，使用下面这种方式可以直接拆分元组int_data, str_data = q.get() 注意：Queue每次获取数据以后都会把获取的数据删除从内部，所以不用担心获取到重复的数据。使用q.queue属性，可以得到里面所有的数据，返回的是一个deque对象。 线程事件通知有时我们希望让某一个线程进入等待状态来进行一些其他的处理，当我们某些事情处理完成以后，再唤醒线程，让它从刚才停止的地方继续运行。使用标准库下面的Threading.Event就可以实现。 休眠事件：wait() 唤醒事件：set() 清除事件：clear() 12345678910111213141516171819from threading import Event, Thread# 接收一个Event对象def test_event(e): print('run...') # 让这个线程进入睡眠状态 e.wait() # 当线程被唤醒以后，会输出下面的语句 print('end...')e = Event()t = Thread(target=test_event, args=(e,))# 这里会看到输出了 run...t.start()print('Set Event...')# 唤醒线程会看到 end...e.set() 上面程序最终运行结果为： run…Set Event…end… 注意：当我们程序在一起运行周期内，重复调用e.wait()，第二次调用就无法让线程进入休眠状态了，需要调用e.clear()清除以后，才能再次进入休眠状态。 123456789101112131415161718192021from threading import Event, Threaddef test_event(e): print('run...') e.wait() # 为了重复使用，需要加上e.clear() # e.clear() print('end...')e = Event()t = Thread(target=test_event, args=(e,))t.start()# 第一次成功休眠print('Set Event1...')e.set()t = Thread(target=test_event, args=(e,))t.start()# 第二次休眠失败print('Set Event2...')e.set() 不去掉e.clear()的注释，根据线程的切换顺序，可能得到各种输出结果，可以自己多次尝试看看有什么不同的结果。 去掉e.clear()的注释以后，输出结果如下： run…Set Event1…end…run…Set Event2…end… 守护线程在多线程环境中，我们有多个继承了Thread的类，他们之间相互调用。假设我们此时有一个MyThread的类，它是为其他线程服务的。现在，其他线程的所有操作已经全部完成了，而我们的MyThread的run方法里面有一个死循环，我们怎么在其他线程都完成工作，停止了以后，停止我们的MyThread类中的死循环？ 123456789101112from threading import Threadclass MyThread(Thread): def run(self): while True: # 控制其他各个线程的代码 pass def __init__(self): Thread.__init__(self) # 设置守护线程 self.setDaemon(True) 在12345678910111213141516171819202122232425### 创建线程本地数据有些场景下，我们希望每个线程，都有自己独立的数据，他们使用同一个变量，但是在每个线程内的数据都是独立的互不干扰的。我们可以使用threading.local()来实现：```pythonimport threadingL = threading.local()L.num = 1# 此时操作的是我们当前主线程的threading.local()对象，输出结果为1print(L.num)def f(): print(L.num)# 创建一个子线程，去调用f()，看能否访问主线程中定义的L.numt = threading.Thread(target=f)t.start()# 结果提示我们：# AttributeError: &apos;_thread._local&apos; object has no attribute &apos;num&apos; 对上面的稍作修改： 1234567891011121314151617import threadingL = threading.local()L.num = 1# 此时操作的是我们当前主线程的threading.local()对象，输出结果为1print(L.num)def f(): L.num = 5 # 这里可以成功的输出5 print(L.num)# 创建一个子线程，去调用f()，看能否访问主线程中定义的L.numt = threading.Thread(target=f)t.start()# 主线程中的L.num依然是1，没有发生任何改变print(L.num) 程序运行结果为： 151 由此可见，threading.local()创建的对象中的属性，是对于每个线程独立存在的，它们相互之间无法干扰，我们称它为线程本地数据。 by. 秋名山车神 site: 慕课网 END","categories":[{"name":"多线程","slug":"多线程","permalink":"http://www.cheshen.wiki/categories/多线程/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"http://www.cheshen.wiki/tags/线程池/"},{"name":"Python","slug":"Python","permalink":"http://www.cheshen.wiki/tags/Python/"},{"name":"多线程","slug":"多线程","permalink":"http://www.cheshen.wiki/tags/多线程/"},{"name":"Thread","slug":"Thread","permalink":"http://www.cheshen.wiki/tags/Thread/"}],"keywords":[{"name":"多线程","slug":"多线程","permalink":"http://www.cheshen.wiki/categories/多线程/"}]},{"title":"精通Python爬虫-01-不断前行的蜘蛛","slug":"精通Python爬虫-01-不断前行的蜘蛛","date":"2017-03-12T10:21:05.000Z","updated":"2017-03-29T14:50:56.025Z","comments":true,"path":"2017/03/12/精通Python爬虫-01-不断前行的蜘蛛/","link":"","permalink":"http://www.cheshen.wiki/2017/03/12/精通Python爬虫-01-不断前行的蜘蛛/","excerpt":"声明： 本系列文章原创于慕课网，作者秋名山车神，任何人不得以任何形式在不经作者允许的情况下，进行任何形式的印刷以及销售，转载需注明出处及此声明。 本系列文章更新至少每周一更，将涉及Python爬虫基础，Requests，Scrapy等主流爬虫技术。同时会介绍图片验证码，语音验证码的识别以及我自己设计的一个高并发可扩展易维护的集群爬虫架构。 对文章有任何问题请在下面留言，我会不定期的回复大家。 人非圣贤，如果文章有错别字请大家自行区分或指正出来，我将不定期修改错误的地方。 本系列能否持久更新下去离不开大家的支持与鼓励，以及对原创版权的尊重。","text":"声明： 本系列文章原创于慕课网，作者秋名山车神，任何人不得以任何形式在不经作者允许的情况下，进行任何形式的印刷以及销售，转载需注明出处及此声明。 本系列文章更新至少每周一更，将涉及Python爬虫基础，Requests，Scrapy等主流爬虫技术。同时会介绍图片验证码，语音验证码的识别以及我自己设计的一个高并发可扩展易维护的集群爬虫架构。 对文章有任何问题请在下面留言，我会不定期的回复大家。 人非圣贤，如果文章有错别字请大家自行区分或指正出来，我将不定期修改错误的地方。 本系列能否持久更新下去离不开大家的支持与鼓励，以及对原创版权的尊重。 爬虫的定义爬虫就是通过模拟人类使用浏览器来访问网页的过程，通过一个起始URL地址不断的从请求到的HTML中寻找新的URL地址，如此循环下去，直到我们的目的达成。 什么是URL和HTMLURLURL(Uniform Resource Locator)又叫统一资源定位符。通俗的讲，每一个URL都代表一个资源，而这个资源是存储在不同的计算机上，我们使用固定的协议，主机名，端口号，对应的路径以及文件名这样的格式。就可以通过浏览器来访问到存放在某一个主机上面的资源。 如：http://www.imooc.com:80/static/img/index/logo-newyear.gif 这就是一个URL地址，它所代表的的含义就是，使用http协议来访问www.imooc.com这个主机，和这个主机的80端口进行通信，找到static目录下的img目录下的index目录下的logo-newyear.gif资源。这个URL就代表了唯一的一个资源，无论是我还是你来访问，请求到的都是这一个资源。所以叫做，统一资源定位符。 HTMLHTML(HyperText Markup Language)又叫做超文本标记语言。文本我们都知道，我们最简单的TXT文档，就是一个文本，那么什么是超文本呢？我们可不可以理解为是一种比文本更加强大的东西？因为我们的TXT文档连最基本的针对某个字符进行加粗或者插入一个图片都做不到，所以我们需要一种更加强大的文本，那就是超文本。 所以HTML不仅仅可以包含文字，还可以包含程序，视频，音频，图片，链接，等等。它具有一种独特的书写格式，简单易学，并且体积较小，容易阅读，可以在互联网进行低带宽传输，并且能够很好的被其他程序解析，比如我们的浏览器。有些人看到前面可能会问：Word文档也可以包含视频音乐和图片啊，为什么Word不叫超文本呢？这个问题非常好，因为Word文档设计本身就不是让它在互联网进行传输的，我们都知道互联网传输什么最重要？那就是速度，Word文档不仅体积大，而且它的编码还不是采用的字符的编码形式，而是采用微软特有的形式进行编码，我们需要依靠特定的软件，比如Office才能编辑这种文档。而不像我们的HTML，他可以使用最原始的文本文档进行编辑，它在传输的时候就是最简单的字符，可以被任何其他程序轻易的读取。 当我们在使用浏览器访问一个HTML文件的时候，服务器就会把这个文件中包含的字符传输给我们的浏览器，浏览器获取到这个文件以后会把里面包含的视频，图片，样式，音频等等统统请求过来，然后根据里面当初大家规定好的代码标签来将页面漂亮的显示出来，而不是一个原始的代码文本。 如下图，这是慕课网首页经过浏览器渲染后的样子： 我们再来看一下没有经过渲染的样子： 是不是非常的难看，虽然有前端基础的同学能够看出他们代表的意思，但是你能够在脑海中想象出这么漂亮的一个页面吗？恐怕非常困难吧，而我们的浏览器并没有修改任何的东西，只是把当初定义HTML语言时候规定的样式给展现了出来。那么也就是说，这其实是浏览器搞的鬼，实际上服务器返回的还是上面的没有渲染过的代码。 那么既然浏览器是一个程序，它能够发送请求来获取一个URL地址对应的资源，我们能不能够也写一个类似的程序，但是我们不需要去渲染漂亮的页面，我们只需要从HTML代码中获取一些我们感兴趣的东西就可以了。于是，爬虫技术应运而生。 不断前行的蜘蛛任何事情它一开始出现的目的，一定是为了解决某些问题的，爬虫也不例外。在互联网开始之初，人们建立了许多的网站，我们都知道服务器其实就是一个计算机而已，它也拥有IP地址。我们访问一台服务器的时候，其实访问的就是它的IP地址，但是IP地址并不好记啊，所以人们发明了域名，域名就很好记了。比如说：www.imooc.com，www.baidu.com，www.qq.com。但是随之而来的问题就出现了，这么多的网站，我不可能每个域名都记住啊，你让我记住十几个，甚至是天赋过人，记住几百个，但是其他更多的域名怎么办呢。如果我想找到一个音乐网站，我该怎么找呢。 这时，就有人想，能不能做一个程序，我让它把世界上所有的网站都找到，然后大家都在自己网站的HTML代码里加入一个特殊的标记，如果你这个网站主要是音乐，你就在里面写上音乐还有其他跟音乐相关的关键词，我的程序就通过分析你们这些页面里包含的东西还有你们的域名存储在我的服务器里，而我来建一个网站。这个网站什么都没有，只有一个搜索框，别人想找一个音乐网站就在框里输入音乐两个字，点搜索我就把你的域名给别人显示出来，这样所有人都只用记住我的网站域名就可以了，其他的根本不用记。 到这里，可能很多人都明白了，这就是我们的搜索引擎。没错，爬虫的最初目的竟然是为了解决人们记不住互联网上众多的域名而诞生的。但是随着大数据和人工智能时代的到来，数据显得越来越重要，谷歌，百度，腾讯，凭什么他们能够屹立在互联网行业的最巅峰？那就是因为他们掌握的数据量太恐怖了，百度谷歌每天通过人们搜索的关键词就可以判断出全世界的一个趋势，他们知道人们对什么感兴趣。包括腾讯，庞大的用户群体，空间，等等。通过人物之间的关系，以及各种动态就可以分析出某些群体他们感兴趣的产品。 21世纪什么最重要？产品。我们来看滴滴打车等软件就可以知道，一个好的产品可以让一个普通人身价过亿。那么如何做好一个产品，自然是庞大的数据分析。根据不完全统计，各大招聘网站中数据挖掘工程师的工资不断的飙升，并且稳居IT行业前列。并且在2016年出现了震惊世界的一件事，那就是国际围棋大师，李世石大战谷歌人工智能阿尔法狗，最终败给了阿尔法狗。 这件事再次让人们重新思考人工智能是否可行，但是无论怎样，人工智能技术绝对离不开庞大的数据量，那么这些数据如何获取，就完全依靠我们的爬虫程序。越来越多的人投身这个行业，越来越多的爬虫进入了这个庞大的互联网，它们目的明确，不断的顺着网络寻找下一个目标，像一个不知疲倦的蜘蛛，永远前行。","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.cheshen.wiki/categories/爬虫/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.cheshen.wiki/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.cheshen.wiki/tags/爬虫/"}],"keywords":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.cheshen.wiki/categories/爬虫/"}]},{"title":"精通Python爬虫-02-初遇","slug":"精通Python爬虫-02-初遇","date":"2017-03-12T10:21:05.000Z","updated":"2017-03-29T14:50:59.402Z","comments":true,"path":"2017/03/12/精通Python爬虫-02-初遇/","link":"","permalink":"http://www.cheshen.wiki/2017/03/12/精通Python爬虫-02-初遇/","excerpt":"声明： 本系列文章原创于慕课网，作者秋名山车神，任何人不得以任何形式在不经作者允许的情况下，进行任何形式的印刷以及销售，转载需注明出处及此声明。 本系列文章更新至少每周一更，将涉及Python爬虫基础，Requests，Scrapy等主流爬虫技术。同时会介绍图片验证码，语音验证码的识别以及我自己设计的一个高并发可扩展易维护的集群爬虫架构。 对文章有任何问题请在下面留言，我会不定期的回复大家。 人非圣贤，如果文章有错别字请大家自行区分或指正出来，我将不定期修改错误的地方。 本系列能否持久更新下去离不开大家的支持与鼓励，以及对原创版权的尊重。","text":"声明： 本系列文章原创于慕课网，作者秋名山车神，任何人不得以任何形式在不经作者允许的情况下，进行任何形式的印刷以及销售，转载需注明出处及此声明。 本系列文章更新至少每周一更，将涉及Python爬虫基础，Requests，Scrapy等主流爬虫技术。同时会介绍图片验证码，语音验证码的识别以及我自己设计的一个高并发可扩展易维护的集群爬虫架构。 对文章有任何问题请在下面留言，我会不定期的回复大家。 人非圣贤，如果文章有错别字请大家自行区分或指正出来，我将不定期修改错误的地方。 本系列能否持久更新下去离不开大家的支持与鼓励，以及对原创版权的尊重。 urllib简介 首先需要说明的是，本系列教程，全部采用Python3.5作为开发环境，因为我不想做一些影响Python3发展的事情，如非必要，请使用Python3。 urllib是Python提供的一个用来访问网络的库，在Python3中有了较大的改动，首先最明显的就是整合了urllib2和urllib，使用起来更加的明了简单。 第一个请求123456789#!/usr/bin/env python# -*- coding: utf-8 -*-# 引入urllib下的request模块import urllib.request# 使用urlopen发送请求，并获得响应response = urllib.request.urlopen('http://www.imooc.com')print(response.read()) urllib.request模块：包含了跟请求相关的方法。 urlopen：可以根据链接或Request对象来发送请求，并将结果返回为一个HTTPResponse对象。结果对象包含一个read方法，可以输出获取到的HTML代码。 使用Request对象12345678910#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.request# 创建一个Request对象req = urllib.request.Request('http://www.imooc.com')# 使用Request对象发送请求response = urllib.request.urlopen(req)print(response.read()) 和上面有所不同的是，这里我们使用了Request方法来发送请求，这里或许看不出什么差异，我们将在下个案例中看到他们的区别。 发送POST请求123456789101112131415161718#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.requestimport urllib.parsepost_value = &#123; 'keyword': '大数据', 'pageCount': '1'&#125;# 把dict对象转换为请求的url参数字符，并按照utf-8转换为字节post_data = urllib.parse.urlencode(post_value).encode('utf-8')# 发送携带参数的POST请求req = urllib.request.Request('http://www.iimedia.cn/do_search.jsp', data=post_data)response = urllib.request.urlopen(req)print(response.read()) urllib.request.Request在Python3中，必须接受一个字节类型的data，这是和Python2不同，需要区分。和requests这种库不同，Python的urlopen方法，会根据有没有携带data参数来决定是发送GET请求还是POST请求。 再试试带参数的GET请求1234567891011121314#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.requestimport urllib.parseurl = 'http://www.imooc.com/search/course'get_value = &#123;'words': 'Python', &#125;get_data = urllib.parse.urlencode(get_value)# 拼装后的URL就是http://www.imooc.com/search/course?words=Pythonreq = urllib.request.Request(url + '?' + get_data)response = urllib.request.urlopen(req)print(response.read()) 欺骗的大师我们来思考一个问题，那就是类似于腾讯，百度，乃至慕课网。愿意别人通过爬虫来获取网站上的一些数据吗？我想这种问题不用回答也知道结果，自然是不愿意。那么服务器是如何知道到底是什么在访问它呢？答案是通过请求的数据包中，一个叫做user-agent的参数来区分的，我们通过浏览器的开发者工具可以轻松的找到，如果不知道怎么使用的，可以参考我在慕课网的课程浏览器开发者工具使用技巧。 我们只需要使用真正的浏览器访问一下网站，然后在开发者工具中找到这个参数，把里面的内容复制下来。 例如我的是： Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36 可以看到，这里面包含了我的浏览器版本以及内核版本，系统的版本和位数等等。 这就像给我们的爬虫披上了一层伪装的外衣一样，可以悄无声息的渗透到我们想去的地方。 1234567891011#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.requestheaders = &#123;'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36'&#125;url = 'http://www.imooc.com'# 给headers参数赋值req = urllib.request.Request(url, headers=headers)response = urllib.request.urlopen(req)print(response.read()) 通过urllib的源码，我们可以看到，urllib.request.Request方法接收的参数： 12&gt; self, url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None&gt; data和headers参数，如果我们不指定，默认都是为空的。 异常的处理异常的处理，对于任何一个语言任何一个程序都是非常重要的，它意味着我们的程序在遇到错误以后需要如何处理。那么同样的，为了我们的爬虫不轻易的就遇到异常停止，我们需要对一些异常进行操作。 URLError这是urllib内的一个异常类，正如其名，通常在遇到URL链接有问题时，会抛出这种异常，比如下面的代码： 12345678#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.requestimport urllib.error# 注意这里的URL地址，我们故意写成htturllib.request.urlopen('htt://www.imooc.com') 运行上面的代码，得到一个错误： urllib.error.URLError: 那么我们如何捕获这个异常，在遇到这种问题时，不要让我们的程序崩溃呢？ 1234567891011#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.request# 所有urllib异常的类，在Python3中都移植到了urllib.error里面import urllib.errortry: urllib.request.urlopen('htt://www.imooc.com')except urllib.error.URLError as e: print(e.reason) 运行上面的程序，我们会得到一个输出信息： unknown url type: htt 可以看到，这个内容，就是前面我们输出的 urllib.error.URLError: 尖括号里面的内容，信息被存储在URLError对象里的reason属性，它就说明了导致异常的原因。 上面是我们协议写错，这种情况在真实的爬虫环境中，几乎不会遇到，但是我们常遇到的就是URL访问地址不可达，什么情况会导致这种现象发生？比如有一个网站里面有一个链接指向一个地址，但是那个地址的域名到期了，域名所有者没有续费，那这个域名现在就属于一个不可访问的地址了，我们来模拟这种情况，来看一下会报出什么异常信息。 1234567891011#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.requestimport urllib.errortry: # 这个域名显然不会有人注册，不排除有人看了教程以后注册这个域名... urllib.request.urlopen('http://www.imooc1imooc2imooc3.com')except urllib.error.URLError as e: print(e.reason) 上面的代码运行会输出以下信息： [Errno 11001] getaddrinfo failed 此处我们明显的发现，多了一个中括号，里面有一个Errno是11001。像这样的错误码还有很多，大家带Errno可以在网上搜索，也可以根据后面的错误信息自己去判断。 HTTPError刚才我们说的都是URL上的一些错误，那么我们在HTTP请求的时候一定也会遇到很多的问题，比如常见的我们访问的页面不存在。需要注意的是，页面不存在不代表我们的请求没有发到对方的服务器，而是发到对方的服务器以后，对方的服务器没有找到我们要访问的网页，给我们返回一个错误码。这和上面的根本都找不到对方的服务器，有本质上的区别。 那么我们来看一下不捕获异常访问一个不存在的页面会怎样： 1234567#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.request# 显然慕课网目前没有cheshen.html这个页面urllib.request.urlopen('http://www.imooc.com/cheshen.html') 运行以后，得到我们期望的异常： urllib.error.HTTPError: HTTP Error 404: Not Found 其中HTTP Error 就是错误编号，这里是404，冒号后面是错误原因，意思是没有找到。 这些编号有很多，大家可以参考百度百科给出的资料：HTTP Error。 相比URLError，HTTPError更容易产生，也更容易让我们的程序变得脆弱不堪，所以没啥说的，捕获异常： 1234567891011#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.requestimport urllib.errortry: urllib.request.urlopen('http://www.imooc.com/cheshen.html')except urllib.error.HTTPError as e: print(e.reason) print(e.code) 运行以后输出了： Not Found404 不用我说，大家也知道reason代表错误信息，code代表错误代码。 而我们如果修改上面的代码： 12&gt; print(type(e.code))&gt; 就会看到 这说明code是一个int类型的数值，我们可以在代码中进行比较来判断我们是遇到了哪种错误，以决定接下来我们的爬虫如何工作。","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.cheshen.wiki/categories/爬虫/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.cheshen.wiki/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.cheshen.wiki/tags/爬虫/"}],"keywords":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.cheshen.wiki/categories/爬虫/"}]},{"title":"python选择排序","slug":"python选择排序","date":"2016-10-27T12:21:49.000Z","updated":"2016-10-30T08:21:51.667Z","comments":true,"path":"2016/10/27/python选择排序/","link":"","permalink":"http://www.cheshen.wiki/2016/10/27/python选择排序/","excerpt":"算法+数据结构=编程 算法实际上是依托于数据结构的，没有数据结构就没有算法。 以下代码在Python3.5上正常运行，转载请注明出处。 By.秋名山车神","text":"算法+数据结构=编程 算法实际上是依托于数据结构的，没有数据结构就没有算法。 以下代码在Python3.5上正常运行，转载请注明出处。 By.秋名山车神 O(n^2)级别的排序算法选择排序将一个列表：10, 9, 8, 7, 6, 5, 4, 3, 2, 1 进行从小到大排序： 普通实现1234567891011121314151617181920# arr为待排序的列表# 在从0到n之间进行排序def selection_sort(arr, n): for i in range(n): # 假定i的位置是最小值 minIndex = i for j in range(i+1, n): if arr[j] &lt; arr[minIndex]: minIndex = j # 交换arr[i] 和 arr[minIndex]的值 arr[i], arr[minIndex] = arr[minIndex], arr[i] return arrif __name__ == '__main__': # 生成测试数据 a = [10,9,8,7,6,5,4,3,2,1] selection_sort(a, 10) for i in a: print(str(i), end = \" \") print() 自定义类型排序Student.py12345678910111213141516class Student(object): def __init__(self, name, score): self.name = name self.score = score # 重载小于运算符 def __lt__(self, otherStudent): # 类似其他语言的三元运算符，如果分数相等则比较名称 return (self.score &lt; otherStudent.score if self.score != otherStudent.score else self.name &lt; otherStudent.name) # 只比较分数 # return self.score &lt; otherStudent.score # 当使用print打印一个对象的时候，按照这种格式显示 def __repr__(self): return \"Student: \" + self.name + \" \" + str(self.score) main.py1234567891011121314151617181920212223242526272829303132333435363738394041from Student import Studentdef selection_sort(arr, n): for i in range(n): # 假定i的位置是最小值 minIndex = i for j in range(i+1, n): if arr[j] &lt; arr[minIndex]: minIndex = j # 交换arr[i] 和 arr[minIndex]的值 arr[i], arr[minIndex] = arr[minIndex], arr[i] return arrif __name__ == '__main__': # 测试模板函数，传入整型列表 a = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] selection_sort( a , 10 ) for i in a: print(str(i), end = \" \") print() # 测试模板函数，传入浮点数列表 b = [4.4, 3.3, 2.2, 1.1] selection_sort(b,4) for i in b: print(str(i), end = \" \") print() # 测试模板函数，传入字符串列表 c = [\"D\", \"C\", \"B\", \"A\"] selection_sort(c,4) for i in c: print(str(i), end = \" \") print() # 测试模板函数，传入自定义结构体Student列表 d = [Student(\"D\", 80), Student(\"C\", 100), Student(\"B\", 95), Student(\"A\", 95)] selection_sort(d,4) for i in d: print(str(i)) print() 或许我们可以更灵活SortTestHelper.py12345678910111213141516171819import randomimport timeclass SortTestHelper(object): def generate_random_array(n, rangeL, rangeR): assert rangeL &lt;= rangeR arr = [None for _ in range(n)] random.seed(int(time.time())) for i in range(n): arr[i] = random.randint(rangeL, rangeR) % (rangeR - rangeL + 1) + rangeL return arr def print_array(arr): for o in arr: print(o, end = \" \") print() main.py123456789101112131415161718192021222324252627282930313233343536from SortTestHelper import SortTestHelper\"\"\" Python的每一个数字都被描述为一个不可变对象 它需要不断的创建对象，修改引用，垃圾回收，等等一系列操作 所以它不像其他语言那样能够快速操作庞大的千万次的数值运算 Python社区为了弥补这一缺点，使用C语言实现了排序功能\"\"\"def selection_sort(arr, n): for i in range(n): minIndex = i for j in range(i+1, n): if arr[j] &lt; arr[minIndex]: minIndex = j arr[i], arr[minIndex] = arr[minIndex], arr[i] return arrif __name__ == '__main__': N = 10000 arr = SortTestHelper.generate_random_array(N, 0, 10000) \"\"\" 我为什么要这么做？ 1. Python社区不希望程序员自己再造轮子 2. 前面我们已经使用模仿C++的算法实现过了 3. 这正是Python最大的魅力之所在 4. 人生苦短，我用Python 我想降序排列？ arr.sort(reverse = True) 干杯！ \"\"\" arr.sort() # Python的特点导致操作数字会特别的慢 # selectionSort(arr, N) print(arr) 可以增加一个消耗时长测试的方法SortTestHelper.py1234567891011121314151617181920212223242526272829303132import randomimport timeclass SortTestHelper(object): def generate_random_array(n, rangeL, rangeR): assert rangeL &lt;= rangeR arr = [None for _ in range(n)] random.seed(int(time.time())) for i in range(n): arr[i] = random.randint(rangeL, rangeR) % (rangeR - rangeL + 1) + rangeL return arr def is_sort(arr, n): for i in range(n - 1): if arr[i] &gt; arr[i+1]: return False return True def test_sort(sort_name, sort_def, **kwargs): arr = kwargs.get(\"arr\") n = kwargs.get(\"n\") start_time = time.time() sort_def(arr, n) # 十万个数字的级别测试需要非常久的时间，建议使用Python内置函数测试十万级别 # 是不是被内置函数的效率惊呆了？ # arr.sort() # end_time = time.time() assert SortTestHelper.is_sort(arr, n) # python标准建议我们使用format来替换字符串，而不是%。 print(\"&#123;:.6f&#125; s\".format(end_time - start_time)) main.py123456789101112131415161718from SortTestHelper import SortTestHelperdef selection_sort(arr, n): for i in range(n): minIndex = i for j in range(i+1, n): if arr[j] &lt; arr[minIndex]: minIndex = j arr[i], arr[minIndex] = arr[minIndex], arr[i] return arrif __name__ == '__main__': n = 10000 arr = SortTestHelper.generate_random_array(n, 0, n) # 可以看到Python操作大量数值类型是如此耗时 SortTestHelper.test_sort(\"fun1\", selection_sort, arr=arr, n=n)","categories":[{"name":"算法","slug":"算法","permalink":"http://www.cheshen.wiki/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.cheshen.wiki/tags/算法/"},{"name":"算法入门","slug":"算法入门","permalink":"http://www.cheshen.wiki/tags/算法入门/"},{"name":"python算法","slug":"python算法","permalink":"http://www.cheshen.wiki/tags/python算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.cheshen.wiki/tags/数据结构/"},{"name":"选择排序","slug":"选择排序","permalink":"http://www.cheshen.wiki/tags/选择排序/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://www.cheshen.wiki/categories/算法/"}]},{"title":"如何成为一名程序员？","slug":"如何成为一名程序员？","date":"2016-10-22T09:59:17.000Z","updated":"2017-03-29T14:50:52.480Z","comments":true,"path":"2016/10/22/如何成为一名程序员？/","link":"","permalink":"http://www.cheshen.wiki/2016/10/22/如何成为一名程序员？/","excerpt":"为什么会有这篇文档？之前有幸看过Eric Raymond(埃里克·史蒂文·雷蒙德)写的一篇文章《如何成为一名黑客》，感觉像黑夜里的灯塔一样，能够给人很多的启迪。在计算机这条道路上，无论是程序员，黑客，网管，还是其他任何相关的角色，有一个老司机带你，能让你看清自己的方向，不至于迷失自我。记得在初二那一年因为老师的一句很看不起人的话，走上了编程这条路。高中，大学，不断的更换自己所学的语言。这期间我学习了VB，Java，Perl，Python，C#，C，C++，汇编，原因就是因为自己不知道该学什么好，究竟应该学什么才是对的，怎么样才能更好的在编程这条路走的更远，我学习VB的时候看到别人说Java如何的厉害，学Java的时候又听别人说Java不能做大型游戏和操作系统…那一刻我是真的迷茫了。这是我下定决定要写这篇手记的初衷，我不奢望它能成为像《如何成为一名黑客》这样被人称为黑客入门宝典的文章，只希望能让看到这篇手记的你，不再迷茫。","text":"为什么会有这篇文档？之前有幸看过Eric Raymond(埃里克·史蒂文·雷蒙德)写的一篇文章《如何成为一名黑客》，感觉像黑夜里的灯塔一样，能够给人很多的启迪。在计算机这条道路上，无论是程序员，黑客，网管，还是其他任何相关的角色，有一个老司机带你，能让你看清自己的方向，不至于迷失自我。记得在初二那一年因为老师的一句很看不起人的话，走上了编程这条路。高中，大学，不断的更换自己所学的语言。这期间我学习了VB，Java，Perl，Python，C#，C，C++，汇编，原因就是因为自己不知道该学什么好，究竟应该学什么才是对的，怎么样才能更好的在编程这条路走的更远，我学习VB的时候看到别人说Java如何的厉害，学Java的时候又听别人说Java不能做大型游戏和操作系统…那一刻我是真的迷茫了。这是我下定决定要写这篇手记的初衷，我不奢望它能成为像《如何成为一名黑客》这样被人称为黑客入门宝典的文章，只希望能让看到这篇手记的你，不再迷茫。 什么是程序员？程序员在外行人看来，可能是一个带着厚镜片眼睛，满脸的胡茬，大T恤，人字拖，双眼无光，整天坐在电脑前噼里啪啦的敲代码，凡是电脑相关的问题，他都要会。 其实并不是那样的，从计算机诞生之初，世界上第一台计算机出现的那一刻，就意味着世界上已经有了第一批程序员。如果非要我说程序员是什么的话，我只能说，计算机就像无所不能的阿拉丁神灯，而程序员则懂得如何与它交流沟通的办法，在网络的世界中，如果说骇客是破坏神，那么程序员就是创世神。(ps:这里不用黑客是因为，传统意义的黑客，像侠客一样，他们不会做无意义的破坏，他们只是乐于追求技术的巅峰和分享自己的技术。) 程序员可以创造任何你所能想到的程序，任何不可思议的东西，任何在别人看来魔幻的东西，程序员都能通过不断的超越自我来一一实现，虚拟现实和人工智能技术的突破，已经说明了这一切。有很多人认为自己是程序员，我想说不，其实你不是，你只是一个码农。而有很多人自嘲自己是码农，其实他们才是真正的程序员。 程序员和码农真正的区别在于，码农只会每天无休止的工作，今天重复昨天的任务，明天复制今天的生活。一年又一年，一个项目又一个项目，同样的框架，同样的配置文件，同样的结构，甚至同样的接口和底层代码。每天他们所做的就是Ctrl+C，Ctrl+V。甚至，从来不去关心技术，也不会去分享自己的技术，他们闭门造车，生怕自己的技术被公司的新人，被其他的同行学去。自己写的项目要里三层外三层的绕来绕去，防止别人偷窃自己的代码。 而程序员，他们乐于分享，追求技术的巅峰，不断超越自我。码农所关心的是如何尽快完成一个项目，程序员关心的是如何让一个项目更加的优雅稳健。 程序员的态度 这个世界充满了问题，等待我们去解决。 不要重复的制造轮子 崇尚自由 编程使人快乐 乐于分享正如你所看到的，程序员的态度和黑客的态度惊人的相似。实际上程序员和黑客之间并没有太多的不同之处，首先他们都是编程高手，只不过他们所专注的领域不同，黑客研究的是如何让软件拥有更强大的破坏力，而程序员所研究的是软件如何承载更高的并发，如何去抵挡黑客的攻击。 和所有创造性的艺术一样，成为大师的最有效方法，就是模仿大师的精神——智力上的模仿还不够，还要从感情上进行模仿。修行之道：关注大师的言行，跟随大师的举动，和大师一并修行，领会大师的意境，成为真正的大师。引用自《如何成为一名黑客》 1. 这个世界充满了问题，等待我们去解决。程序员就是为解决问题而生的，如果这个世界不存在任何问题，那么就不需要程序员。当人们需要通讯，需要沟通的时候，诞生了MSN，QQ，Skype。当人们需要社交的时候诞生了FaceBook。当人们需要网络购物的时候，诞生了亚马逊，天猫。就和所有先有鸡还是先有蛋的问题一样，到底是什么先需要网络通讯后诞生的通讯软件，还是先有的通讯软件，后来人们才适应了网络通讯。这些问题，人们不得而知，但是上面提到的每一个人，他们如今都在福布斯富豪榜位列前茅。你所发现的问题，或者你所要解决的问题，他的受众面有多广，那么你对于人类的贡献就有多大，而你的名字也会被篆刻在历史的丰碑上。这个世界拥有无数的问题，即使百度，腾讯，阿里，拿掉了所有的技术，依然有无数的问题等待我们去发现，去解决。你要相信，即使是谷歌的产品经理，也不如一个专修平房漏水的大爷更了解他所在行业的问题。从你最熟悉的环境出发，发现问题，并解决它。 2. 不要重复的制造轮子对于已有的东西，程序员不会去重复的创造它，除非之前的东西非常的差。如果他是一个开源项目，应当提出你的修改意见，或直接贡献你的代码。除非它毫无亮点可言，否则你不需要重复制造轮子的过程。要相信一句话，最出色的程序员，也不如一个社区的人共同努力所创造出来的产品完美。你应当将时间和精力放在更有意义和价值的事情上。 3. 崇尚自由如果你跟我说，程序员是没有自由的，那么我想你可能是在生活的压力下迷失了自我。自由并非是来去自如，而是你的工作岗位可以由你自己去支配，你可以选择是在天台或者坐在滑滑梯上，甚至是在家里办公。要记住一句话，自由永远是属于强者的，为了追寻自由，你必须不断的突破和超越自我。还要记住自由并非是不工作，事实上如果能够处在一家伟大的公司，和一群伟大的人共事，那将是一件非常令人愉快的事情。 4. 编程使人快乐你是否每天上班以后，打开电脑和你的编程工具以后，就开始了自己一天的工作，浑浑噩噩直到吃午饭。下午继续重复这一过程，日复一日，你已经忘记了你的初心，忘记了你一开始学习编程时的那种激情和梦想。没错，并非每个人都有梦想，也并非每一个梦想都可以实现，更不是说每一个程序员都要去实现自己的梦想。我认为，程序员最大的梦想就是快乐的编程。试想一下，在一天的清晨，一杯青柠檬茶和一个机械键盘，听着你所喜欢的音乐，跟着欢快的节拍敲打着。就好像多年前的那个深夜，一个人，一架钢琴，一轮明月，一杯苦酒，造就了永世流传的月光交响曲。 5. 乐于分享如果你觉得程序员都应当牢牢地保护好自己的代码，那么绝对不会有今天的Github这种开源项目托管的网站。更不会有一个个流传至今还被人使用着的项目，可能有人会说某些著名的产品都没有开源。相信我，他们不开源是因为他们的代码写的太烂，如果被别人看到就没有人敢使用他们的产品了。一个人，一个团队，一个公司的力量，绝对比不上全世界的程序员。计算机之所以发展的如此迅猛，就是有无数的乐于分享的你们，这些分享并非仅限于你某个项目的源码，也可以是一篇文章，甚至是一次回答，这对于你来说，都是分享，这一过程将使你得到快乐，并获得行业其他人的认同。 程序员的基本技能 学习如何编程 学会使用互联网 能够看懂英语 1. 学习如何编程如果你是一个新手，对于编程一无所知，恭喜你，你将在这里找到你的路。如果你是一个入门者，对于编程略有了解，恭喜你，你将在这里坚定你的路。如果你是一个老鸟，对于编程早已融会贯通，同样恭喜你，你将在这里成为开拓者。 在过去的几年里，我学习了多门编程语言，我发现其实他们都大同小异，一旦你掌握其中一门，想学习其他任何一门都会很容易，是真的非常的容易，我可以毫不客气的说，你可以一周之内就学会别的语言。除非你并没有真正的掌握编程的思想，我们总是强调思想，这就像小说中的法则一样，领悟其中一门法则，再去领悟其他法则，可能还不是特别的快，但是参考起来还是比新手要快。但是一旦领悟了法则的本质，那么再领悟其他任何一门法则都会很轻松。你并不需要苦恼你不理解这些，放松你的心态，学习和工作中，一切都会水到渠成。 编程语言众多，条条大路通罗马，忘记你在任何位置看到的任何关于某个语言不好的地方，也忘记你看到的任何关于某个语言的优势，那些都是毫无意义的。实际上你点开任何一个语言的官网，他总有一个与其他语言的对比图，对比的结果它总是比其他语言更有优势，那么这些毫无意义的评价又有什么价值呢。 即使是世界上人口最少的冰岛，那里的人民使用他们独有的语言，依旧能够快乐幸福的生活着。 不管我下面说了什么，如果你已经决定或者正在学习一门语言的话，坚定的走下去，如果今天因为我的话而放弃你目前的所学，你还是趁早离开这个行业吧。如果你还没有选择一门语言，那么你或许可以参考我的建议。 在我学习的多门语言中，从来没有哪一门语言能让我感到惊艳，或者说，像弹钢琴一样的写代码，Python做到了。最初接触Python是因为要写一个网络爬虫，当时看了一些参考资料就写出来了，而且代码十分的简洁，只有短短的三十多行代码。不过但是并没有太大的惊喜，只是觉得，哎呦，这个语言，不错哦。因为Java我也完全可以自己整合一个包，只用几句代码，也能完成这一切，但是当时想到这个时候，我忘记了一个很严重的问题，那就是我在自己造轮子。 Python带给我的惊喜远远不止于此，又一次偶然的机会让我使用Django(Python的一个开发网站的框架)，这一次我是彻底的被它的简单，优雅而吸引。很多人推荐初学者学习Java，C++，甚至是VB和汇编。 实际上，我曾经也经常推荐想学习编程的朋友，去学习Java，因为它没有像C++那么难以理解的东西。但是Java的面向对象的思想，足够没有编程基础的人喝一壶了，所以我不建议新手学习Java。而Python被列为黑客必须要掌握的技术之一，同样，我认为程序员也必须掌握Python。因为它真的非常的简单和强大。有人称Python为瑞士军刀，还有人称它为胶水语言，在国外很多学校都是以Python作为教学的语言。Python拥有庞大的用户群和社区，Google，NASA。所有你耳熟能详的公司，他们或多或少都在使用着Python。事实上，Perl也同样简洁，而且它对于正则表达式的支持是难以置信的，但是它的用户群体并不多，而且不够活跃，选择一个用户群体活跃的语言，将会让你语言问题时，获得更多人的帮助。 而学习编程，最好的方法就是阅读，不管是官方的文档还是别人写的教程，如果是视频教程就更好了。一开始学习的时候，不要太过于纠结底层的原理，就像你开车一样。一开始你只是学习怎么开这个车，你并不了解内部的构造，所以你不会修理它，但是随着你经验的加深，你开得多了，对它内部的了解就多了，慢慢的你也可以修理它了。 最后强调一次，坚持你目前所学的。 2. 学会使用互联网身为一个程序员，如果你不会使用互联网，那就太弱了。学会使用百度和翻墙，这对于每个程序员来说是必备的技能。 3. 能够看懂英语英语对于你来说是必要的，如果你的英语不好，你不必苦恼。编程这么难的东西，你都敢于学习它，英语又算得了的什么？26个字母分开认识，组合起来一样能够认识，更何况还可以借助翻译工具。这并非让你在学习编程之初就需要掌握英语，而是在你编程达到一种比较高的层次以后可以考虑的事情。英语可以让你和国外众多的高手交流心得，同时还可以让你参与国外大型的开源项目开发。 提高自己在编程圈中的地位 贡献开源项目 帮助测试并调试开源项目 发布有用的信息 帮助新人 和其他行业不同，程序员想要提高自己在圈中的地位，并不需要多么惊世骇俗的经历，甚至不需要多么厉害的技术。提高自己的地位，可以让你在求职或创业过程中，获得更多同行业的帮助，你的付出都会得到回报，相信我。 1. 贡献开源项目永远不要以为在Github上贡献一个项目有多么的困难，一次机缘巧合之下，我发现Python中一个很大的开源项目Requests文档中有一句代码书写错误，于是我修改了它，我的提交得到了项目管理团队的认同，他们收录了我的修改。就是这么的简单，细心和简单的英语水平，就能让你贡献一个几百万人使用的项目。甚至，你可以自己发起一个开源项目，正如我所说的，程序员都是乐于分享的，如果你发起某个项目，并且说的足够的详细，一定会有人非常乐意和你一起开发和维护这个项目的。 2. 帮助测试并调试开源项目如果你费尽心机也没有能够贡献一个开源项目的话，千万不要灰心，你还可以帮助开源项目进行测试和调试。如果发现其中的问题，可以去他们的主页提出问题，如果能够给出解决意见，那真是太好不过了。帮助测试开源项目是一件非常容易的事情，在Github任何一个项目的主页中，他都拥有当前稳定版本和测试版本以及过去版本。当前稳定版本就相当于正式版，是经过测试没有问题，发给用户使用的。测试版本就是目前正在开发的版本，修改或增加了很多新的内容，但是没有经过详细的测试，开发团队也不确定会出现什么问题，于是发出来希望有经验的开发人员能够协助他们共同去测试。 3. 发布有用的信息你还可以活跃在各大程序员社区，撰写自己的博客。慕课网，博客园，知乎，都是一个不错的选择，在那里有很多的新人，也有很多的前辈。无论发布任何的信息，都会帮助到别人。无论你是新人还是老手，都可以发布你的文章，这可以是你学习的心得体会，也可以是你面试的经历，还可以是你学习编程之路的微笑与眼泪，或是你工作中的所见所想。都会得到大家的阅读，不会有任何人会出言不逊或否定你的技术，即使写错了也不用担心，别人会指出你的错误，这样才能一直进步。永远不要担心别人指正你的错误，除非他说的是不对的。 4. 帮助新人你曾经和他们一样，永远不要忘记这句话，当新手提问一些在你看起来非常可笑的问题时，要告诉自己，曾经我和他一样。不要去嘲笑他，在解答他问题的同时，记得告诉他，如何学会排查这些问题，以及如何更好的使用搜索引擎去寻找答案。要记住，你轻蔑的回答，可能毁灭了一个和曾经的你一样有梦想的人。工作之余和假期无聊的时候，浏览一下别人的问题，选择一些回答，这都可以帮助你提升自己的技术和地位。记住，这是一件长期的事情，一天回答一百个问题，然后九十九天不回答，不如一百天每天回答一个问题，你说呢？ 最后几点疑问我需要掌握数学吗？我希望你今天能够记住我说的这几句话，程序员的工作和数学真的没有太大的关系，只要你能够了解加减乘除，大于小于这些基本的关系就足够了。就像那些年中柯景腾说的，“就算十年后我连log都不知道是什么，一样可以活的很好”。我们程序员同样如此，就算你不知道什么叫做正弦余弦，一样可以很好的编程。真正需要数学来做的工作，都是那些博士的工作，我们的任务只是改变世界而已，所以我们不需要数学的基础。当然，如果你拥有这个技能，也不会影响什么，相反它还会让你在理解程序逻辑的时候简单一些。 程序员就要会修电脑吗？没有任何人下过这个规定，修电脑是网管的任务，程序员所要思考的就是如何更优雅的工作。 程序员都很内向吗？这取决于个人，我觉得学习的同时应当不要忘记健身和娱乐，周末可以约几个朋友一起出去唱唱歌，吃个烧烤什么的。不是说某个行业的人都要内向，我身边很多同事都特别的外向，并且桃花运不断。 怎么样才能知道自己已经是一个合格的程序员了？恭喜你，当你对自己问这个问题的时候，你已经是一个合格的程序员了，接下来你所要做的就是，把你所决定的付诸行动。从今天开始，分享一个学习的小心得，回答一个小问题。请记住，这并不需要你有多么高深的技术，哪怕你今天才开始学习编程，依旧可以写出一篇文章来，向人们分享你成长的同时，还可以给其他人以帮助。程序员圈子是一个乐于分享和有爱的圈子，请分享你每一次成长的经历，一定会得到别人的赞同，而如果有人出言不逊，你不必理会，他一定是一个没有素质的人。 我需要一台高配置的电脑吗？实际上是不需要的，你只要拥有一个搭载512MB内存和单核的处理器，以及一块50G硬盘的电脑足以。当然，它可能不足以让你运行大型的开发工具，但是小型的sublime或是Vim，也是一个很不错的选择，至少他们比文本文档漂亮的多。 我的家人建议我去学习其他行业，我该去吗？再从头看一遍我们的文章，然后问自己，我想要做一个程序员吗？如果你得到的答案是确定的，那么我为你感到骄傲，无论谁的否定，都不能阻挡你在这条路走下去。你不仅不能放弃，反而要努力拼搏，拥有一片属于你的天空，让否定你的人刮目相看。而如果你得到的答案是否定的，那么我为你感到遗憾的同时，我建议你选择一个你真正喜欢的行业，即使这个行业不是程序员，我也会为你喝彩。你是一个独立存在的人，所以，你要自己决定你未来的路，不管你喜欢的职业是什么，走下去，别回头。 我该从哪里开始学习？如果你想寻找一个友好免费全面的学习平台，那么我建议你选择慕课网，这真的不是在安利什么广告，我接触过许多的学习网站，他们拥有很多的问题，比如说太多的收费内容，以及社区不够全面化。慕课网则不同，不仅有用大量的免费课程，还有便宜的实战课程，要知道的是，实战课程通常都是大型项目，看完以后对于之前基础知识的整合是非常有帮助的，而非实战内容，都是免费的。同时我也向你推荐YouTube这真的是我用过的，最棒的网站，在上面拥有你想象不到的资源。几乎你想学习任何东西都可以在上面找到别人制作的视频，并且是精心制作的视频，这一切不需要你支付任何的金钱。比较遗憾的是，大多数都是英文的视频。 如果你想要选择一本书的话，我推荐图灵社区的动物书，它是我见过的最好的编程语言书，没有之一。 同时Github，Google+和stackoverflow也是非常好的，能够帮助你成长的平台，但是这三个平台都需要有一定的英文基础。其中Github能够和许多开源项目的作者面对面交流，而Google+则拥有很多的社区，能够找到你所学习语言的社区，并且其中有很多的大神，至于stackoverflow则号称如果它里面都没人能解决的问题，那你的问题一定是无法解决的，可想而知它的魅力之所在。 人工智能会让我丢失工作吗？至少，在我们活着的时候，不需要担心这个问题。人类的大脑又岂是简单的算法能够完成的？ 开源是否会让我得不到任何的收入？我想这个问题，Linux之父从来没有担心过，因为他一份简历投去任何一家公司，上面只需要写一行字：我创造了Linux。他所得到的工资恐怕是数以千万而且还有公司的股权，这难道不比一个收费软件赚得多吗？更何况他得到的远不止于此。 我已经年纪很大了，现在学习是不是晚了？从来没有人给程序员入门限定一个年龄，以前没有，现在没有，未来更不会有。 我需要多久才能掌握？这取决于你的努力程度和你的聪明程度，虽然我不想提到这个问题，但是我不得不说，聪明才智也是一个重要因素。值得庆幸的是，我们大部分人的智商都是差不多的，只有个别智商超群的人，那是他们的天赋。我们只要付出更多的努力，同样可以超过他，勤能补拙不是说着玩的。通常情况，能在半年内使用一门语言进行开发，两年内能够对一门技术有非常高的了解。但是真的想在这个行业达到令人尊敬的地位，你需要一生去学习。 最后说几句 永远不要嘲笑新手 记住你的初衷 任何时候都不要忘记代码的美观 优雅高效 乐于分享 感谢能够看到最后的你，希望这篇文章，能够给你带来一些帮助，起码能让你觉得不再迷茫，我的目的就达到了。你可以将本文以文字或是链接的形式分享到任何地方。如果可以的话，我希望你能够直接分享文章的地址或者是在转载的时候加上出自哪里，以便更多的人加入我们这个大家庭。世界的未来，依靠各位去改变，记住我所说的，从现在开始行动，从码农转变为真正的程序员。从今天开始，乐于分享，快乐编程。 (注：如果有错别字，给大家带来阅读上的困难，我表示歉意，同时希望你能够指出错误的位置，以便于我来修改它。我将会在文章的底部增加上提出修改意见人的名字。多人提出同一修改，则以最先提出的人为准。) 本文由以下人员共同协作完成（排名不分先后）@秋名山车神 @qq_癫狂是一种病_03633840 @小丨小菜鸟","categories":[{"name":"入门指南","slug":"入门指南","permalink":"http://www.cheshen.wiki/categories/入门指南/"}],"tags":[{"name":"入门指南","slug":"入门指南","permalink":"http://www.cheshen.wiki/tags/入门指南/"},{"name":"程序员","slug":"程序员","permalink":"http://www.cheshen.wiki/tags/程序员/"}],"keywords":[{"name":"入门指南","slug":"入门指南","permalink":"http://www.cheshen.wiki/categories/入门指南/"}]},{"title":"我本微末凡尘，却也心向天空","slug":"我本微末凡尘，却也心向天空","date":"2016-10-20T12:56:32.481Z","updated":"2016-10-30T08:10:53.193Z","comments":true,"path":"2016/10/20/我本微末凡尘，却也心向天空/","link":"","permalink":"http://www.cheshen.wiki/2016/10/20/我本微末凡尘，却也心向天空/","excerpt":"自信可改变未来，问谁又能做到？ 有时候总是想写点什么，但是双手放在键盘上的时候，又不知道从何说起，我有时候总是在想，我们人来到这个世界上，究竟是为了什么，为了一天天的工作？为了找一个爱自己的伴侣？这个问题曾经困扰了我很久。","text":"自信可改变未来，问谁又能做到？ 有时候总是想写点什么，但是双手放在键盘上的时候，又不知道从何说起，我有时候总是在想，我们人来到这个世界上，究竟是为了什么，为了一天天的工作？为了找一个爱自己的伴侣？这个问题曾经困扰了我很久。 记得在高中的时候，我是班上学习最差劲的几个学生，喝酒打架、翻墙上网，不知道写过多少的检查，逢年过节父母肯定不敢跟别人提起我的成绩，人生的前二十年，从来没有让自己的父母骄傲过。直到高三那一年，发生的一件事改变了我的人生轨迹，那是2011年，深圳举办大学生运动会，我们学校要选一些保安过去，一个月一千五百块钱，我也不知道为什么就同意去了，或许冥冥之中老天想要给我一次改变自己的机会。坐着严重超载的大巴，花了三十个小时，终于来到了对我来说是梦寐以求的城市：深圳。因为在这里有无数伟大的人物，有无数伟大的公司，到了以后公司简单的安排了一下，我就和另一个同学一起，被分派到福田区的一个发电站里面，在里面负责看这些设备不被人破坏，当时我是夜班。记得印象最深刻的一件事情就是，我身上只有三百块钱，旁边最便宜的是十八块钱一份的米饭，根本吃不起，于是我出去想找个超市买点泡面面包什么的，由于不知道路只能打了一个出租车，花了15块钱，到了以后买了两百块钱的方便面和面包（你们可以想象有多少），本来回去的时候想走回去省点钱，自以为自己记住了回去的路，于是走着走着迷路了，但是我记得我住的地方是福田二路的江苏大厦旁边，于是我就问别人怎么走，那是第一次让我感受到这个城市的冷漠，我问的出租车司机，他们都说不知道，最后没办法只能让一个司机把我送过去，结果转过一个路口就到了，花了13块钱。PS：那时候我的手机还是按键手机，不是安卓系统，没有百度地图。 我每一顿吃两片面包，一根香肠，有时候撕开一袋泡面，把热水倒进袋子里，直接在袋子里面吃，这属于逢年过节级别的。面包就是那种六块钱一袋里面有十几片那种，从来没吃饱过。就这样过了两个月，这两个月期间，我每天最大的爱好就是坐在楼梯上看着铁栏外面的汽车，一分钟最少过去四十辆宝马和奔驰，而且还让我看到了林肯和法拉利，第一次见到这么多的豪车，第一次见到这么高的楼，但是这里留给我的只有绝望。终于到了离开的那一天了，我走的那天站在马路边上，望着身后生活了两个月的地方，我对自己说：我一定会回来的。 回到家以后，虽然开始努力改变了，但是不幸的是，高考来了。我高中上的是中专，所以参加的也是职业高考，只能考计算机专业，当初选择中专为计算机专业就是因为喜欢玩游戏，我曾经很自豪的事情就是我玩过当时所有流行的网络游戏。高考只考了385分，选择了我们省会的一所大学，是一个三流都不如的大专，到了大学以后，我们班只有二十个人，而且他们学习都不怎样，而我高中还学过一些程序，这让我的自信心盲目的膨胀，老师的水平也很差劲，这让我更加的自大，我认为普天之下没有我不会的东西了，所以我就经常不去上课还和宿舍的一起打游戏。直到大二的时候，老师让我代表学校去参加职业技术大赛，那是我第一次感到挫败，我得了最后一名。 重新回到学校以后我开始努力的学习，但是我没有任何的方向，Java、C++、C、.NET，这些都学过，而且都学的一瓶子不满，半瓶子咣当。终于到了大二的后半年，我决定离开我的学校，我要去我心中一直向往的那个城市。 回到家里以后，家人想让我去投靠深圳的一个亲戚，让我去他的工厂里面做保安，我受够了这种生活，我说我要自己闯出一片天地来，我跟家人列举了比尔盖茨，乔布斯，马化腾这些名人的例子，家人总是说，你别想疯了。这句话伴随我十几年，我的理想总是被家人打击着，这不怪他们，因为我一直让他们失望，一直失望。但是深圳的那个亲戚想让我等几天，给我找一个好点的工作，但是我一刻也不愿意等待。又过了两周，家人终于决定让我自己来深圳闯荡。又是三十个小时的车程，我这一次有的是激动，是对自己心中承诺的兑现，那一刻我认为自己轻轻松松就能找到工作。到了深圳以后，我暂住在同学的舅舅家里，那天晚上学习到一点多，白天出去找工作，第二天找了一天的工作，一个面试官对我说：就你这样，不要工资我们都不会要你的。那一天下午五点多，一个人站在龙岗华为的旁边，我看着川流不息的车，我问自己，我可以吗… 到了六点的时候，迎来了一个房产销售公司的面试，老板让我帮他维护他们的网站，增加一些新开售楼盘的信息，同时还要跟着销售出去卖房子，当时他说一个月1900，我说给2000吧，他说行吧，反正也不在乎那一百块钱。就这样我在深圳安定了下来，从进入深圳的那一刻起，我真正明白了一件事，梦想不是靠嘴说的，是要实际行动的，我每天在公司被老板骂，还要打电话给别人推销房子，被客户骂，还要笑着去讨好别人，每天晚上六点钟下班以后独自一个人学习到十二点。后来一个朋友给我推荐了慕课网，于是我一边看网上找来的教学，一边看慕课网的各种知识点和案例，两个月，我用了两个月的时间学完了Java基础所有的部分，当时我自己写出了一个Spring的框架，当然我写的那个很简单，只是使用反射，还有Java的注解类，还有动态代理这些实现的。那个时候我已经明白了自己的不足，差的太远了，于是我再一次开始找工作了，或许别人不愿意使用没有工作经验的，我投了一百多封简历，没有接到任何电话。我再一次的灰心了，直到三天以后，我接到了一个面试电话，是南山区的一个公司，面试的过程很顺利，面试官问的所有问题我都答上了，最后技术总监问我说，那么多面试的人，我们为什么要选择一个没有经验的人呢。我想了很久，我不知道该怎么说，我说，我在印象笔记有一千多条笔记这样可以吗。那个总监看了我很久，然后当时就告诉我被录取了，试用期三千，转正五千，我当时心情的激动，无法使用语言去表达，回想起刚到深圳的时候连地铁都不会坐，还是问了保安才知道乘坐地铁。我给家里打电话说了这件事，家里人都不相信我能够找到工作。 虽然找到了工作，但是我仍然没有忘记时刻学习，依然每天到家第一件事就是打代码，我的人生除了学习就是工作。从学校出来到深圳以后，我没有一天是停止学习的，过年在家都要看一会书。那时候经常叫沙县小吃的外卖，录取成功的那一天，我跟原来的经理说我不干了，然后就走了，到现在还有一千块钱的工资在他那里没有给我。那天晚上我走在回家的路上，耳边想起了Beyond的光辉岁月，直到今天，我还非常喜欢海阔天空和光辉岁月这两首歌，它们依然激励着我。我当时告诉自己，一定要在深圳这个城市好好的活下去，而且还要活的很精彩，我当时有种这天再遮不住我眼，这地再埋不住我心的感觉。两个月以后过年回家了，但是公司由于是做在线购买彩票的，而彩票禁止在网上售卖，公司倒闭了，正好是过年前的几天公司倒闭了。那一年回家，我是火车站票回去的，站了二十多个小时，我当时告诉自己，你要记住，你今天所经历的一切都是提醒你未来的每一天不能有丝毫的松懈，同样的对深圳说了一句话，下次再来的时候我会在这里过的很好，我会坐飞机回家，于是，我去年兑现了这个承诺。 终于，第二年来到深圳以后，和朋友一起经历了短暂的创业失败以后，找到了一份月薪八千的工作，那是我第一次让自己的父母在亲戚面前抬起头。他们不怕再跟别人提起我，也不怕别人夸自己的孩子，他们也有了一点和别人谈论的资格，这份工作我一直做到了现在，也有一年多了，工资也涨到了九千，虽然跳槽以后可以拿到两万，但是我还是很感激这个当初能够信任我的公司，所以一直也没有离开，偶尔和朋友接接项目也不在乎那些钱。那一刻，让我想到了我初中的数学老师，那天她当着全班同学的面抽我一耳光，然后说如果我要有一天出息了，她倒着走路，我到今天依然记得这句话，我期待登上福布斯富豪榜那天回去看她倒着走路。 我想要说的是，每一个程序员心中，一定有一个梦想，就算不说，我们也知道这个梦是改变世界。无数伟大的公司，各种传奇的经历，我想说的是，梦想每个人都有，不同的是，有些人面对梦想他们只能远远的看着，从来不付出任何努力，我人生的前二十年就是如此。还有一种人自以为付出了一些努力，就是世界上最伟大的存在，自己不成功都是因为没有背景，都是因为各种外在因素导致的，大学的那段时间我就是如此。还有一种人，他们不畏艰险，忍受着各种的困难和挫折，他们一次又一次的跌倒，一次又一次的爬起来，他们从来不会忘记学习，因为他们明白，他们的力量还不足以承载他们的野心，现在我就是这种人，我同样相信来慕课网学习的你，也是这种人。 我们活着不是为了别的，我们只是为了让我们在乎的人可以过上更好的生活，可以让他们自豪的说出你的名字，可以让自己心爱的人可以买到世界上任何的东西，而不是自己的妻子，孩子，父母，只能看着橱窗里昂贵的奢饰品望而兴叹。有朋友问我，你是怎么学的，我告诉他说，我只是用别人打英雄联盟的时间学习罢了，他们今天玩得比我开心，未来他们只能看到那么大的天地，而我的未来又岂是一个深圳能够满足的。在硅谷有更加广阔的天地，我们的征途是星辰大海。请记住，未来的你，一定会感谢现在拼命努力的自己。看到这里或许有些人感觉很可笑，不求能让所有的人醒悟，只希望能够明白，再好玩的游戏，也没有马尔代夫的阳光沙滩和美女好玩。然而这些东西并不需要多么出色的成绩只需要年薪二十万你就可以轻松做到这些，这对你来说只不过是每天坚持过来学习罢了，一年以后你就可以实现。当然努力学习的同时，还要注意早点休息，尽量十二点以前睡觉，记得经常健身，制定一个规范的计划，每天健身多久学习多久。 当我们失去方向，不知所措的时候，唯一可以做的就是迎着风雨努力的前行，我非常喜欢一句话，我本微末凡尘，却也心向天空。送给大家，同时希望大家坚信：长风破浪会有时，直挂云帆济沧海！","categories":[{"name":"光辉岁月","slug":"光辉岁月","permalink":"http://www.cheshen.wiki/categories/光辉岁月/"}],"tags":[],"keywords":[{"name":"光辉岁月","slug":"光辉岁月","permalink":"http://www.cheshen.wiki/categories/光辉岁月/"}]}]}